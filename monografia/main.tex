\documentclass[a4paper,11pt]{article}
\usepackage[left=3cm,top=3cm,right=2cm,bottom=2cm]{geometry}
\usepackage[brazilian, english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[numbers]{natbib}
\usepackage{epigraph}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{setspace}
\usepackage[hidelinks]{hyperref}
\usepackage[bottom]{footmisc}
%\usepackage{xcolor}
\usepackage[dvipsnames]{xcolor}
\usepackage{adjustbox}
\usepackage{verbatim}
\usepackage{float}
\newcommand{\tabitem}{~~\llap{\textbullet{\ensuremath{\bullet}}}~~}
\newcommand*{\SignatureAndDate}[4]{%
	\parbox{7cm}{
      \centering
      \rule{6cm}{1pt}
       #1

       #2
    }
    \hfill
\parbox{7cm}{
      \centering
      \rule{6cm}{1pt}
       #3

       #4
    }
}%

\floatstyle{ruled}
\newfloat{program}{thp}{lop}
\floatname{program}{Program}

\onehalfspacing
\setlength{\parskip}{1em}

\title{Relatório de Estágio III}

\renewcommand{\familydefault}{\sfdefault}

\begin{document}
\selectlanguage{brazilian}

%%% CAPA %%%

\begin{titlepage}

\begin{wrapfigure}[2]{l}{0.2\textwidth}
	\label{Logo UFABC}
	\vspace{-1\baselineskip}
	\centering
	\includegraphics[width=0.25\textwidth]{images/Logo_UFABC}
\end{wrapfigure}

\uppercase{Universidade Federal do ABC}

\uppercase{Bacharelado em Ciência da Computação}

\vfill
\begin{center}

\uppercase{\textbf{Projeto de Graduação em Computação}}

\vfill

\uppercase{Bruno Cesar Porto de Arruda}
\vspace{1cm}

Orientador: Prof. Dr. Vladimir Moreira Rocha

\vfill

Santo André -- SP

2019
\end{center}
\end{titlepage}

%%% FIM DA CAPA %%%

%%% FOLHA DE ROSTO %%%

\begin{titlepage}
\begin{center}
\uppercase{\textbf{Bruno Cesar Porto de Arruda}}

\vfill

\uppercase{\textbf{Um sistema distribuído com permissão de acesso a prontuários de pacientes por meio de Smart Contracts}}
\end{center}

\vfill

\hfill \begin{minipage}{0.5\textwidth}
Trabalho submetido à Universidade Federal do ABC como parte dos requisitos para a conclusão do Bacharelado em Ciência da Computação.
\vspace{1cm}

Orientador: Prof. Dr. Vladimir Moreira Rocha
\end{minipage}

\vfill

\begin{center}
Santo André -- SP

2019
\end{center}
\end{titlepage}

%%% FIM DA FOLHA DE ROSTO %%%

\begin{center}
\uppercase{\textbf{Dedicatória}}
\end{center}
	xxx.


\newpage
\begin{center}
\uppercase{\textbf{Agradecimentos}}
\end{center}

\noindent	Ofereço meus sinceros agradecimentos:

\vspace{1cm}


%%% ABSTRACT - PORTUGUÊS %%%
\newpage
\begin{abstract}

\noindent FAZER NO FINAL.

\noindent \textbf{Palavras-Chave:} Blockchain; Ethereum; Contratos Inteligentes; CBA.
\end{abstract}

%%% ABSTRACT - INGLÊS %%%

\newpage
\selectlanguage{english}
\begin{abstract}
\noindent FAZER NO FINAL.

\noindent \textbf{Keywords:} Blockchain; Ethereum; Smart Contracts; ABE.
\end{abstract}

\selectlanguage{brazilian}

%%% SUMÁRIO %%%
\newpage
\tableofcontents

%%% LISTA DE FIGURAS %%%
\newpage
\listoffigures

%%% LISTA DE TABELAS %%%

% \newpage
% \listoftables

% -------------------------------------------------------------------- %
\newpage
\section{Introdução}

A tecnologia Blockchain~\cite{nakamoto2008bitcoin}...

\subsection{Objetivo geral}

Criar um sistema, com base em contratos inteligentes executados em uma Blockchain, que permita o acesso a prontuários eletrônicos dos pacientes via políticas de acesso baseadas em atributos.

\subsection{Objetivos específicos}

\begin{itemize}

\item Criar uma taxonomia de permissões no contexto de saúde.

\item Analisar como funciona a criptografia baseada em atributos (\textit{attribute-based encryption}, em inglês).

\item Analisar como funcionam a tecnologia Blockchain {\color{red}escolher a tecnologia} e os contratos inteligentes.

\item Implementar os contratos inteligentes para dar acesso aos prontuários eletrônicos utilizando a taxonomia e a criptografia baseada em atributos.

\item Implantar e executar os contratos inteligentes em uma arquitetura Blockchain.

\end{itemize}

\subsection{Justificativa}

% -------------------------------------------------------------------- %
\newpage
\section{Fundamentação Teórica}

\begin{itemize}
    \item {\color{red}Cada parágrafo deve ter em torno de 10 linhas}
    \item {\color{red}Não mostrar código.}
\end{itemize}

\subsection{Criptografia baseada em atributos (CBA)} \label{sec:sub:cba}

{\color{ForestGreen}Explicar quando nasceu, quem a criou, e qual foi o problema que estava resolvendo (basicamente que a criptografia chaves publica/privada precisa ser criada para cada usuário que precisa de permissão e com a por atributos não). (2 parágrafos).}

{\color{ForestGreen}Explicar alguns conceitos da CBA (chave pública/privada/etc para que sirva como base do exemplo mostrado no último parágrafo (1 parágrafo).}

{\color{RoyalBlue}Explicar e fazer uma imagem explicando a derivação de atributos em um ambiente multi-autoridade, através do ID, que então gera uma chave mestra privada e uma chave pública, e várias outras chaves privadas particulares derivadas a partir da chave mestra e todas compatíveis com a mesma chave pública.}

{\color{ForestGreen}Explicar os benefícios do CBA (2 parágrafos).}

{\color{ForestGreen}Explicar um exemplo de uso (1 parágrafo). Pode usar algo assim: https://medium.com/asecuritysite-when-bob-met-alice/towards-true-security-attribute-based-encryption-20d5799aeda6}

\subsection{Blockchain Ethereum}

{\color{ForestGreen}Explicar quando nasceu, quem a criou e que resolve o problema de não estar atrelada somente a transações financeiras, tendo um uso mais abrangente para qualquer domínio de aplicação. (2 parágrafos).}

 Sistemas de pagamentos virtuais sugiram para atender a necessidade do comércio à distância através da internet, e esses sistemas passaram a depender exclusivamente de instituições financeiras vistas como entidades confiáveis para a transação de pagamentos eletrônicos.
 Neste modelo centralizado, uma autoridade é considerada confiável e é encarregada da manter a consistência de um sistema, processando as transações dos usuários e rejeitando tanto transações impossíveis (e.g., em um contexto financeiro, transações com data passada, saldo negativo ou outros parâmetros incorretos), quanto transações que são válidas mas inconsistentes (e.g., transações com gasto duplo).
 Sistemas de pagamentos virtuais operam sobre a moeda fiduciária, que é emitida pelo sistema bancário, cuja gestão e controle máximos estão, na maior parte dos países, nas mãos de um Banco Central. Também é atribuído ao sistema bancário a posição de confiança para emissão da moeda, julgando que ele seja imparcial em sua política de expansão ou retração monetária, provendo a liquidez necessária para o mercado. O sistema bancário unido ao sistema de pagamentos virtuais perfaz todo o sistema financeiro.

Um sistema baseado em confiança tem fragilidades inerentes à sua natureza, tais como o abuso de autoridade pela imposição de regras arbitrárias, exposição de informações das partes aos entes ditos confiáveis, possibilidade de manipulação do sistema em proveito próprio e, em um contexto comercial, uma institucionalização do risco de fraude, pois os sistema de pagamentos, por força regulatória, possuem mecanismos de reversão de transações, trazendo prejuízos ao destinatário do pagamento nos casos onde o serviço contratado não é reversível, aumentando os riscos e custos entre as partes.

O \emph{Bitcoin}\footnote{Bitcoin pode significar tanto a unidade de valor utilizada nas transações, quanto a rede de processamento em sua totalidade, o que inclui a unidade de valor, seus protocolos e tecnologias subjacentes como o código e software oficiais.
Assim, o sentido do termo pode variar entre moeda, sistema, rede, programa ou plataforma, no caso em que é utilizado como uma dependência por outras soluções.}
surge como a primeira alternativa viável de uma rede descentralizada ponto-a-ponto de pagamentos que não depende de uma entidade central confiável.
A confiança é depositada aos próprios integrantes da rede de processamento, através de um conjunto de algoritmos e incentivos que, uma vez postos em funcionamento, conseguem produzir o registro válido e imutável das transações, sob a premissa de que a maior parte dos membros da rede não estejam coordenados em um ataque para alterá-lo \cite{nakamoto2008bitcoin}.
Mais importante do que processar pagamentos, o Bitcoin revelou-se um experimento útil para demonstrar a viabilidade de uma ferramenta sem precedentes denominada como \emph{Blockchain}, por meio da qual o consenso distribuído pôde ser obtido.
Já há milhares de
soluções\footnote{Em 13 de novembro de 2019, há mais de 4.700 projetos registrados no \href{https://coinmarketcap.com/}{CoinMarketCap} e mais de 6.100 no \href{https://coinlib.io/}{coinlib}, dois dos maiores sites agregadores de informações do mercado de criptomoedas.}
baseadas em Blockchain, que se tornaram conhecidas como \emph{criptomoedas}, embora nem todas elas tenham o objetivo de serem utilizadas primariamente como um sistema de pagamentos, como é o caso da plataforma \emph{Ethereum}, utilizada nesse trabalho.
Entender o conceito de Blockchain é um passo necessário para compreender a mecânica que põe a rede \emph{Ethereum} em funcionamento.

{\color{ForestGreen}Explicar o que é (distributed ledger, cadeia de blocos, transação) e suas características (anonimato, imutabilidade, distribuição). (2 parágrafos).}

Em seu cerne, a Blockchain é uma estrutura de dados com suporte somente à inserção de novos elementos, encadeados por referências ao hash de seu conteúdo, levando portanto a uma quebra da estrutura no ponto em que um elemento foi modificado, impedindo que a modificação passe despercebida e produzindo a propriedade de imutabilidade aos dados, na medida da segurança da função de hashing utilizada.
Essa estrutura originalmente foi concebida como uma forma de impor uma ordem cronológica a documentos digitais sem depender da integridade do provedor deste serviço e preservando a privacidade de seus conteúdos \cite{Haber1991}.
A Blockchain é composta por blocos, onde cada um deles referencia o bloco que o antecede, de forma recursiva, até que exista a referência a um bloco especial que inicia essa sequência, denominado como \emph{Bloco Genesis}.
Um bloco é organizado em um cabeçalho e um corpo.
O cabeçalho armazena informações relevantes para a verificação de sua integridade, contendo dados como o hashing do bloco anterior, da árvore Merkle das transações no corpo do bloco, um hashing do próprio cabeçalho, e metadados relevantes como versão do protocolo e parâmetros utilizados para o algoritmo de consenso.
A Figura \ref{fig:blockchain} demonstra essa estrutura.

\begin{figure}[htp]
    \centering
    \includegraphics[width=\textwidth]{images/exemplo-de-blockchain.png}
    \caption{Estrutura básica de uma Blockchain}
    \label{fig:blockchain}
\end{figure}

Satoshi Nakamoto projetou a Blockchain do Bitcoin para atender as necessidade de uma moeda, contudo o protocolo extrapola essa finalidade, suportando operações mais complexas, além do simples escopo de um sistema de pagamentos.
Isto porque, ao invés de implementar uma lista preemptiva e exaustiva de todas as transações que pudessem vir a ser necessárias, o protocolo do Bitcoin imbui as transações com uma linguagem de script baseada em pilha, intencionalmente turing-incompleta, sem loopings ou recursividade, contendo algumas operações aritméticas, lógicas e criptográficas julgadas úteis para modelar as transações que a rede viria a suportar \cite{Narayanan2016a}.

As transações, unidades elementares da Blockchain, dependem dessa linguagem de script para definir o comportamento de suas entradas e saídas, duas listas que as compõem e indicam respectivamente de onde estão vindo os fundos e qual será a destinação deles.
Uma saída especifica uma quantidade em bitcoins e usa um script para 'trancar' este valor sob um desafio criptográfico, podendo ser utilizada por uma transação posterior que a referencie em uma de suas entradas.
Uma entrada contém uma referência à uma transação, especificamente para alguma de suas saídas que pretende utilizar, e o script que resolve o desafio relacionado àquela saída.
A checagem de uma transação se dá pela união dos scripts de entrada e saída e sua execução pelo cliente do Bitcoin, sendo considerada válida se, e somente se, para cada uma de suas entradas, a união do script com a respectiva saída de transação referenciada por ela resultar, ao fim do processo, em um valor verdade na pilha de execução do
interpretador\footnote{O artigo \cite{Bistarelli2019} ilustra em suas figuras o processo de execução de scripts passo-a-passo.}.

Diversos comportamentos foram então modelados, e o mais comumente utilizado entre eles implementa a operação que é o núcleo da rede Bitcoin - a transferência de moeda entre carteiras - implementada pelo script conhecido como P2PKH \emph{(Pay to Public Key Hash)}, que carrega um hash de uma chave pública e condiciona a utilização do valor na saída de uma transação à apresentação da chave pública que corresponda ao hash, juntamente com uma assinatura produzida pela chave privada da respectiva chave pública, permitindo que somente o detentor da chave privada possa utilizar o valor encaminhado a ele por meio da chave pública.
Outros scripts juntamente com este formam um pequeno conjunto de scripts creditados como seguros e alçados ao status de padrão no protocolo do Bitcoin.
Uma transação é considerada padrão quando só utiliza scripts padrões, e mais de 99,9\% das transações na Blockchain são padrões \cite{Bistarelli2019}.
A alta adesão não é coincidência, pois o cliente oficial do Bitcoin não permite a propagação de transações não-padrão pela
rede\footnote{Há outras verificações que impedem o recebimento e transmissão de uma transação na rede. Veja \url{https://en.bitcoin.it/wiki/Protocol_rules\#.22tx.22_messages}},
virtualmente negando o serviço a transações deste tipo, impondo ao seu proponente o ônus de propagar sua transação de forma externa à rede na tentativa de fazê-la alcançar os nós que tenham a eventual chance de incluir um bloco na Blockchain.

Essa linguagem de script demonstra a preocupação no projeto do Bitcoin para poder abarcar, caso fosse necessário, complexidades e regras de transação além do escopo de uma moeda ou pagamento.
Com ela torna-se possível projetar e realizar transações de garantia, vínculos contratuais, arbitragem privada e multi-assinaturas.
Mais ainda do que isso, no início de 2014 \cite{Greenspan2015} o protocolo passou a permitir a adição de até 80 bytes de metadados arbitrários em uma transação, abrindo o caminho, mesmo que limitado, para a utilização da blockchain como um \textbf{livro-razão distribuído} (em inglês \textbf{\textit{Distributed Ledger}}), uma fonte de dados onde seria possível registrar informações públicas, perenes e inalteráveis, acessíveis em qualquer lugar do mundo.
A \emph{Blockchain 2.0} surge para avançar o suporte ao conceito de livro-razão distribuído, trazendo novas tecnologias baseadas em blockchain, destacando-se entre elas as \emph{Smart Properties}, \emph{Smart Contracts} e \emph{DApps (Decentralized Applications)} \cite{Swan2015}.
Essas ferramentas elevam a expressividade e capacidade da Blockchain como uma plataforma para a criação de aplicações financeiras, semi-financeiras, e até mesmo aplicações com ativos que não são financeiros.

%% detalhamento do Bitcoin que o professor disse estar fora de escopo, sobre scripts no Bitcoin
% O Bitcoin permite à princípio scripts com tamanho de até 10 mil bytes e com dados de no máximo 520 bytes na pilha de execução\footnote{Informações retiradas do cliente oficial do Bitcoin, versão 0.19, no arquivo de cabeçalho referente a scripts, linhas {\color{RoyalBlue}\href{https://github.com/bitcoin/bitcoin/blob/0.19/src/script/script.h\#L23}{23}} e {\color{RoyalBlue}\href{https://github.com/bitcoin/bitcoin/blob/0.19/src/script/script.h\#L32}{32}}.}.

%% especificação do tipo de hashing que o Bitcoin faz. Não sei se no Ethereum é assim, então fica de fora do texto até que seja relevante
% Cada bloco tem uma referência única calculada a partir de seu conteúdo por meio de hashing\footnote{Especificamente, é realizado um hashing duplo utilizando SHA-256 nos campos que compõem o cabeçalho do bloco, representados em bytes \cite{bitcoinWikiHashing}.}

{\color{ForestGreen}Explicar que para criar o consenso, ou seja, escolher quem irá inserir o último bloco na cadeia, é necessário utilizar o mecanismo de consenso denominado Proof-of-Work (PoW). Explicar em que consiste o PoW. (2 parágrafos).}

\textbf{Fatos sobre a necessidade consenso}

\begin{itemize}
    \item A Blockchain pode ser centralizada ou distribuída, e pode ser permissionada ou pública.
    \item Uma Blockchain centralizada é operada por uma autoridade central ou um conjunto delas, que serão responsáveis que selecionar transações, montar blocos e adicioná-los.
    \item a Blockchain pública não contém barreiras de entrada para o sistema, e as criptomoedas todas operam nessa política de acesso. Blockchains permissionadas ou privadas surgiram para atender soluções comerciais e empresariais, podendo consistir em uma rede clientes de uma blockchain pública configurada para operar numa rede interna, ou utilizando blockchains com arquiteturas que considerem a permissão de uso, como o Hyperledger Fabric \cite{Indeterminado2019}.
    \item A Blockchain distribuída opera em uma base p2p e foi projetada sob a suposição da ausência de papéis de confiança aos integrantes da rede, o que implica em uma dificuldade óbvia de decidir quem será o responsável por incluir o próximo bloco.
    \item A Blockchain distribuída opera em uma arquitetura p2p e foi projetado para operar sem a confiança em usuários para realizar operações sensíveis e que poderiam destruir a rede em caso de uso mal intencionado. Sem haver um papel fixo para gerenciar a rede, decorre que o acesso a ela torna-se público e irrestrito e sem esse controle perde-se a proporção de nós na rede que sejam mal intencionados, não sendo possível derivar propriedades de segurança que tornariam mais simples o desenvolvimento do sistema.
    \item Devido à homogeneidade de papeis, a única saída é conferir a possibilidade de escrita a todos os participantes da rede, o que acarretaria em cada usuário escrevendo sua própria blockchain e realizando broadcast de sua versão aos demais levaria a múltiplas e incompatíveis versões na rede, destruindo sua funcionalidade. Para resolver essa questão é necessário estabelecer um consenso quanto às alterações na Blockchain e um período de tempo para que o consenso possa se propagar por toda a rede.
    \item O algoritmo de consenso organiza a escrita na blockchain em rodadas, estabelecendo um desafio computacional com uma dificuldade ajustada dinamicamente de acordo com a capacidade de processamento total da rede. Esse algoritmo estabelece que tem o direito de inserir um bloco na Blockchain o nó que apresentar um bloco válido (i.e., um bloco constituído somente por transações válidas) cujo cabeçalho contenha uma solução válida de acordo com a dificuldade pré-estabelecida no último bloco da rede.
    \item a participação no consenso é opcional, sendo possível configurar o software para somente obter os dados da Blockchain provindos da rede, e são denominados como \emph{light nodes}. Integrantes que participam do consenso e portanto tem uma chance de adicionar blocos são denominados \emph{mineradores}.
\end{itemize}

 \textbf{Sobre o Proof-of-Work}

\begin{itemize}
    \item O desafio computacional é baseado na ideia do HashCash \cite{Back2002} e foi denominado como \emph{Proof-of-Work} \emph{(PoW)}.
\end{itemize}
\subsection{Contratos inteligentes no Ethereum} \label{sub:sec:contratos-ethereum}

{\color{ForestGreen}Explicar para que servem e listar benefícios. (1 parágrafo).}

O conceito de \emph{Smart Contract} antecede o advento da blockchain, vislumbrando a possibilidade  de tornar um acordo formal (i.e. um contrato) firmado entre duas ou mais partes em um conjunto de regras computáveis que podem ser, portanto, embutidos no software ou hardware de propriedades com valor e que são controladas por meios digitais, com protocolos estabelecidos para que as partes possam interagir com as regras e desempanhar seus papéis.
Isso possibilita a execução automática do contrato sem a necessidade de intermediários, reduzindo a necessidade de confiança em terceiros e os custos de transação \cite{Bartoletti2019, Szabo1996}.
O Ethereum foi o primeiro e mais bem-sucedido projeto baseado em Blockchain voltado especificamente para a execução de Smart Contracts, fornecendo uma linguagem de programação turing-completa com suporte a funções criptográficas e de consulta de metadados da blockchain, permitindo expressar contratos na forma de programas que podem ser publicados na rede Ethereum e com os quais usuários e outros contratos podem interagir.

Invocações às funções de um contrato se dão por meio de uma transação contendo, entre outros parâmetros, os argumentos para a execução da função e um limite computacional compulsório a esta execução, expresso em termos de um recurso quantitativo denominado \emph{gas}.
O gas é a unidade fundamental do custo computacional na rede Ethereum, é convertido automaticamente a partir do \emph{Ether} --- a moeda base do Ethereum --- e a taxa de conversão é governada por uma equação definida no protocolo da plataforma, levando em conta estatísticas de uso da rede e ajustando o preço da computação de acordo com a demanda registrada na blockchain.
O usuário pode configurar na transação o quanto de gas deseja utilizar, desde que possua o respectivo saldo em Ether, até um limite máximo atribuído pelo próprio protocolo.
Essa mecânica incentiva um uso consciente da capacidade computacional da rede, contorna o problema da indecibilidade quanto ao fim ou não da execução de um programa, impedindo a parada da \emph{Ethereum Virtual Machine (EVM)} diante da execução de funções que, sem tal limitação, ao rodar indefinidamente ou por períodos extensos poderiam perturbar a taxa com que são processadas novas transações, e por fim serve para proteger os recursos do próprio usuário ao interagir com uma função de um Smart Contract cujo custo esteja além da expectativa, quer seja este custo inerente à função (devido à complexidade da operação) ou só produto de um código ineficiente ou mesmo incapaz de terminar.

{\color{ForestGreen}Explicar que a linguagem utilizada é denominada Solidity. Explicar o que é solidity. (1 parágrafo).}

A linguagem na qual Smart Contracts são publicados na rede Ethereum se chama \emph{Ethereum Virtual Machine code (EVM code)} --- uma linguagem de baixo nível baseada em pilhas, similar à linguagem \emph{Forth}.
Visando ampliar o acesso à tecnologia, a Fundação Ethereum desenvolveu também linguagens de programação de alto nível, com sintaxes similares às linguagens mais utilizadas no mercado, com compiladores para produzir EVM code a partir delas. O \emph{Solidity} é uma destas linguagens, com sintaxe similar a Java e C\texttt{++}, dispondo de um compilador com parâmetros configuráveis e um crescente ecossistema composto por padrões de desenvolvimento, bibliotecas e ferramentas de desenvolvimento\footnote{Para se inteirar do ecossistema Solidity, veja \href{https://github.com/bkrem/awesome-solidity}{https://github.com/bkrem/awesome-solidity} ou outras listas publicadas na internet. Entre as bibliotecas, destacam-se a \emph{\href{https://openzeppelin.com/}{OpenZeppelin}}, \emph{\href{https://github.com/dapphub/dappsys}{Dappsys}} e \emph{\href{https://github.com/modular-network/ethereum-libraries}{Modular Libraries}} por atualmente possuírem as maiores bases de usuários, segundo o site \emph{GitHub}.}, destancando-se o ambiente de desenvolvimento e implantação de Smart Contracts \emph{Remix}, utilizada para codificar, depurar e implantar os Smart Contracts do protótipo deste trabalho em redes de teste Ethereum.

{\color{ForestGreen}Explicar o código de um contrato simples que terá o atributo idPaciente, um map de urls de registros médicos e um método addUrl. (1 parágrafo). Explicar que esse contrato é escrito em um arquivo com extensão .sol}

Com Solidity é possível descrever tanto funções quanto estruturas de dados temporárias ou armazenadas na blockchain.
A coleção de dados armazenados na Blockchain compõe o que se denomina como estado da EVM. A Lista \ref{lst:exemploSmartContract} contém um exemplo de uso de Solidity, implementando um contrato que disponibiliza o acesso de resultado de exames a pacientes.

\lstset{basicstyle=\small, numbers=left, language=bash, keywordstyle=\color{blue}, numbersep=1pt, label={lst:exemploSmartContract}, caption={Exemplo de Contrato Inteligente}}
\begin{lstlisting}
 pragma solidity ^0.5.1;
 pragma experimental ABIEncoderV2;

 contract Hospital {

   enum CodigoResultado {negativo, positivo, inconclusivo, falha}

   struct Registro {
     int version;
     CodigoResultado resultado;
     string data;
     uint MinTime;
     uint MaxTime;
     string extHash;
   }

   mapping (string => Registro) registros;
   mapping (address => string[]) patientURLs;

   function addURL (address patient, string  memory url, Registro memory r) public;
   function getRegistro(string memory url) public view returns (Registro);
  }
\end{lstlisting}


{\color{ForestGreen}Explicar um exemplo passo-a-passo (Só TEXTO, Não Código) de um cliente que obtém o contrato do parágrafo anterior e o executa remotamente em uma máquina. (2 parágrafo).}

As funções implementadas no contrato apontam a existência de dois tipos de papeis relacionados, um que provê informações e outro que as consulta. O Smart Contract armazena duas tabelas, uma associando endereços a uma lista de URLs e outra associando um URL a um objeto do tipo Registro, que contém as informações de um exame. Essas tabelas são alimentadas por meio da função \emph{addURL} do contrato, sendo utilizada pelo Hospital que deseja disponibilizar os exames para consulta, e os exames podem ser consultados usando-se a função \emph{getRegistro}. Ambos os papeis necessitam possuir uma identidade na blockchain Ethereum, ou seja, possuir um endereço válido e ser capaz de publicar transações. Também é necessário possuir um cliente capaz de se conectar a rede para poder publicar novas transações. Já para a consulta de dados, é possível utilizar serviços Web de terceiros, como sites de visualização de transação, para resgatar uma atualização particular ou obter o estado atual das variáveis do contrato.

Este exemplo, embora introduza a sintaxe do Solidity, também incorre em três situações problemáticas que podem precisar de conserto. Primeiro, Smart Contracts tem seu código tornado público à rede no momento de sua implantação e suas funções podem ser utilizadas por qualquer usuário da rede. A ausência de controle no uso da função é um risco à integridade dos dados, uma vez que pode estar sujeita a alterações maliciosas. Um contrato deve impor uma política de acesso a funções sensíveis, implementando nestas funções verificações internas do endereço responsável pela interação, permitindo ou não a execução de acordo com tal política. Segundo, dados publicados na Blockchain são sempre públicos em sua visibilidade, embora possam ter diferentes escopos de acesso. Isso quer dizer que os dados relacionados aos exames serão públicos, expondo informações privativas a quem tiver acesso à Blockchain. Uma maneira de mitigar este problema e ainda assim manter a segurança da informação é publicar assinaturas dos dados, que não conterão informação sensível mas ainda servirão para verificar a integridade e imutabilidade dos dados armazenados externamente, na web. Terceiro, mesmo que não configurasse problema de privacidade, este uso da Blockchain tornaria o custo de operação muito alto, uma vez que a cada exame médico haveria um custo para armazenar múltiplas informações, sendo as mais caras as informações de tamanho dinâmico como a variável de texto \emph{data}. Embora o exemplo exemplifique uma estrutura de dados, na prática a Blockchain tem restrições computacionais de uso baseada no alto custo de armazenamento e processamento, o que significa que mesmo em um cenário onde não seja necessário a privacidade, ainda assim há um incentivo para esvaziar as estruturas de dados de informação relativa ao domínio de aplicação e ao invés disso utilizar ela somente como um meio para se verificar estes dados que estarão alocados em bases de dados externas à Blockchain.


% -------------------------------------------------------------------- %
\newpage
\section{Sistema Proposto}

\begin{itemize}
    \item {\color{red} Assuma nesta seção que os conceitos de blockchain, Ethereum, contratos inteligentes e criptografia baseada em atributos já foram definidos e explicados.}

    \item {\color{red}Cada parágrafo deve ter em torno de 10 linhas}

    \item {\color{red}Não mostrar código.}

\end{itemize}

\subsection{Visão Geral}
\label{sec:visaogeral}

{\color{ForestGreen}Explicar que o sistema é composto por X componentes (1 parágrafo).}

O protótipo pode ser abstraído em diferentes módulos de acordo com sua capacidade. A criptografia no esquema ABE é realizada por meio da biblioteca DCPABE. A conectividade com a Blockchain Ethereum é feita por uma classe específica por meio da biblioteca Web3j. A lógica de execução que coordena as atividades entre os usuários do sistema está encerrada em sua maior parte no módulo denominado como Cliente, e em menor parte nos smart contracts que são executados na EVM do Ethereum. Finalmente, o servidor de arquivos pode ser visto como o quinto módulo do sistema.

{\color{ForestGreen}Explicar a função de cada componente (1-2 parágrafos para cada um).}

O módulo do cliente é responsável por incorporar a camada lógica responsável por coordenar as atividades entre os demais componentes.

O módulo do servidor recebe, armazena e envia arquivos criptografados. Presumiu-se que o servidor não fosse confiável, e por isso as informações nele estão sempre criptografadas. Durante os testes, ele também armazenou, de forma temporária, chaves criptográficas que representam a posse de um atributos. Essa função poderia ser transferida para qualquer serviço de transferência de arquivos, como um servidor dedicado sob controle do certificador, um serviço de hospedagem em nuvem ou mesmo por e-mail.

O módulo blockchain é responsável por armazenar de forma permanente e imutável a cifra de um documento, e a política de acesso descrita em termos de uma forma booleana composta por funções lógicas E e OU aplicadas a atributos. A Blockchain para desenvolvimento e teste do protótipo foi uma rede privada do Ethereum.

Também é necessário que a blockchain tenha a capacidade de executar smart contracts, e por isso a rede Bitcoin não foi escolhida para este trabalho. Há muitas opções de projetos de blockchain que suportam smart contracts, e a rede Ethereum foi escolhida por ser o projeto mais popular e bem sucedido no tocante à base de usuários e também ao valor de mercado.

Em conjunção com a blockchain Ethereum, foi utilizado a biblioteca Web3j para conectar o cliente à rede privada. O Web3j fornece a interface para a conexão por meio de socket a um provedor de dados da rede blockchain, que pode ser tanto uma rede local, um cliente ethereum como o geth ou um serviço de terceiros como o Infura. Além disso, fornece implantação de contratos inteligentes, invocação de métodos destes contratos e classes geradas dinamicamente.

{\color{ForestGreen}Figura dos principais componentes em alto nível: programa cliente (exemplo celular ou notebook), servidor de armazenamento de arquivos; blockchain ethereum; contratos inteligentes; servidor de chaves de permissões.}

{\color{ForestGreen}Explicar um cenário de uso passo-a-passo (exemplo, milestone 1, mas com permissões direcionadas ao contexto de saúde, por exemplo um paciente quer dar permissão de acesso a médicos cardiologistas) (2 parágrafos)}.

O protótipo funcionaria então da seguinte forma: Uma paciente de nome Alice receberia um documento digital, como um encaminhamento ou exame, e precisa juntar ele ao seu prontuário médico. Ela utiliza o então o módulo cliente para criptografar este documento de forma segura usando um esquema criptográfico ABE, aplicado ao documento para cifrá-lo de acordo com uma política de acesso. Para este caso de uso, suponhamos que a tal política seja "paciente OU (Hospital-X E Hematologista)". Isso garante acesso ao próprio paciente e aos médicos daquele especialidade, naquele hospital.

Após aplicar criptografia ao documento, simultaneamente o cliente encaminha o documento para um servidor de arquivos e publica os parâmetros da cifra na blockchain, informando além dela informações como o nome do arquivo, o instante da transação e uma referência ao servidor onde o arquivo está alocado. Em um segundo momento, um hematologista do Hospital X, ciente de que atenderá a Alice, usa o cliente para obter informações sobre que arquivos dela estão disponíveis na blockchain. Ao baixar a descrição dos arquivos, ele identifica qual possui uma política de acesso compatível com os atributos concedidos a ele, e então ele requisita o documento cifrado ao servidor de arquivos e decifra o documento utilizando os parâmetros criptográficos publicados na blockchain.

\subsection{Taxonomia de permissões}

{\color{ForestGreen}Explicar que o servidor de permissões deverá ser responsabilidade de uma organização apta para entregar as permissões online (ex. Ministério de Saúde ou algúm conselho federal/regional de medicina) (1 parágrafo)}.

As permissões de acesso a documentos se dão por meio da concessão de atributos a usuários feita por certificadores. O módulo cliente possui a capacidade para tornar qualquer usuário um certificador, que ficará registrado na blockchain a partir de seu endereço de carteira. Entidades como o Ministério da Saúde, os Conselhos Federais e Regionais de Medicina, e todos os laboratórios, clínicas e hospitais se tornariam certificadores, podendo emitir atributos utilizáveis na descrição de políticas de acesso para um prontuário médico. A identidade principal do certificador é seu endereço de carteira ao invés de sua razão social, que é acrescentada ao sistema somente para facilitar sua operação. Portanto, embora o sistema conceda a liberdade para que qualquer usuário torne-se um certificador, não seria possível forjar uma entidade previamente cadastrada a menos que o agente mal intencionado também tivesse posse da chave privada deste certificador.

{\color{ForestGreen}Explicar que a autenticação de uma pessoa para obter a permissão deverá ser realizada de forma externa ao sistema proposto (1 parágrafo).}

Atributos são gerados a partir de requisições feitas por usuários e publicadas na blockchain, por meio de um Smart Contract específico que armazena o estado destas requisições. É necessário que o usuário exista para realizar tal requisição, ou seja, é preciso que ele, anteriormente, tenha interagido com o contrato relativo à gestão de usuários, associando seus dados básicos pessoais a um endereço de carteira. Embora fosse possível criar um canal seguro usando criptografia elíptica para transmitir o arquivo com os atributos ao requisitante, isso estava além do escopo deste trabalho. Desta forma, uma vez geradas as chaves fica a critério do certificador escolher o método de envio, que pode depender ou não de sua infraestrutura de TI, ou pode requerer uma transmissão offline (presencial) dos arquivos que contém os atributos.

{\color{RoyalBlue} Cogitei no texto a entrega física de um arquivo do atributo mas o protótipo implementado sempre supõe que ele vai pegar o atributo de um servidor, não de um sistema de arquivos. Não sei se posso assumir essa redação ou se eu devo remover essa possibilidade do texto.}

{\color{ForestGreen}Explicar que foi realizada uma taxonomia das possíveis permissões que seriam utilizadas no sistema para o contexto médico. (3 parágrafos explicando como foi realizado o levantamento, me lembro que tinha um artigo e uma lista gigante que foi filtrada por quantidade de médicos).}

O sistema proposto pretende integrar diversas bases de dados de diferentes órgãos que, uma vez  certificadores, serão providos com a capacidade de publicar os atributos que forem necessários para a cifra dos documentos. A autonomia dos agentes para criar atributos levanta a necessidade de coordenação entre eles, de forma a manter políticas de acesso harmônicas e funcionais entre documentos que possam ser acessados por entidades distintas. Sem uma proposta de padronização, corre-se o risco das entidades desenvolverem padrões distintos e provavelmente conflitantes no que diz respeito ao escopo, à reutilização e à descrição textual de um atributo.

A diferença na hierarquia da estrutura das instituições na área da saúde, em suas competências e especialidades e suas políticas de acesso à informação podem resultar em diversas configurações distintas e incompatíveis quando descritos em um esquema criptográfico ABE. Um sistema que pretenda permitir o acesso a prontuários médicos distribuídos entre instituições com este esquema deve, portanto, propor também uma norma para a criação e gestão de atributos e de escrita das políticas de acesso . Para atingir este fim, buscou-se o denominador comum entre as exigências e restrições a que devem se condicionar todos os operadores na área da saúde, considerando-se o profissional da saúde como a unidade elementar desta análise , visto que uma política de atributos tem o potencial descritivo para modelar essas distintas responsabilidades.

O Código de Ética Médica (CEM) trata da conduta médica em diversos casos, incluindo também regras de conduta para o acesso à informações médicas, e proveu os elementos necessários para a elaboração de uma taxonomia de condição de acesso a estas informações, conforme mostra a figura 3.2.0 {\color{RoyalBlue}(vou referenciar)}. Isso já permite descrever qual será a política elementar e universal ao qual qualquer prontuário médico deve se submeter:

\[ CFM \vee CRM \vee Paciente \vee Terceiro\textnormal{-}Autorizado \]

Essa política padrão não impede a aplicação de outras políticas em subseções do prontuário, preservando informações de quem a princípio já possui acesso ao prontuário. Caso exista uma política de acesso em alguma subseção do prontuário, será necessário obrigatoriamente adicionar o acesso ao menos aos Conselhos de Medicina. Outras regras podem ser abstraídas a partir da taxonomia, como a necessidade de substituir a partícula $Paciente \vee Terceiro\textnormal{-}Autorizado$ por $Respons\acute{a}vel\textnormal{-}Legal$ caso o paciente seja menor de idade.

A escrita de política de acesso fica sujeita a uma normalização a partir da taxonomia apresentada, mas ainda é necessário adequar o escopo de atribuições dos funcionários de saúde entre os distintos órgãos em que podem trabalhar. A estratégia para propor uma taxonomia abrangente e relevante foi obter dados do DATASUS (Órgão que administra a consulta de informações do Sistema de Saúde Pública) sobre todas as profissões registradas no país na área da Saúde relativas ao início do ano de 2019. Na pesquisa obteve-se mais de 400 profissões distintas, que foram categorizadas pelo nível de ensino e agregadas pela área de atuação. Isso resultou em uma segunda taxonomia, disponível no Anexo I {\color{RoyalBlue}(referenciar)}, que serve como referência para a escrita de política de acesso usando termos e escopos comuns entre os certificadores. A entidade responsável por emitir o atributo a um médico seria o CRM de sua região. As entidades diversas emitiriam o restante dos atributos relativos às outras funções que necessitam acessar os dados do paciente, tais como setor administrativo ou o corpo de funcionários técnico-hospitalar.

{\color{ForestGreen}Figura da taxonomia}.

{\color{RoyalBlue}

\includegraphics[width=\textwidth]{images/taxonomia-de-permissoes.png}

\href{https://mermaidjs.github.io/mermaid-live-editor/#/view/eyJjb2RlIjoiZ3JhcGggUkxcbkExW0NSTV0gLS0gaXJyZXN0cml0byA8YSBocmVmPVwiXCJodHRwOi8vYml0Lmx5L0PDs2RpZ2_DiXRpY2FNZWRpY2luYSNhcnQ5MFwiXCI-QXJ0LiA5MC0tPC9hPiAtLT4gIEJbUHJvbnR1w6FyaW9dXG5CIC0tLXxjb250w6ltfCBDW2RhZG9zIHNlbnPDrXZlaXNdXG5DIC0tLXxzw6NvfCBDMVtkb2Vuw6dhcywgbWVkaWNhbWVudG9zIG91IDxicj4gdHJhdGFtZW50b3MgZXN0aWdtYXRpemFkb3MgPGJyPiBzb2NpYWxtZW50ZV1cbkIgLS0tfGNvbnTDqW18IERbZGFkb3MgY29tdW5zXVxuQiAtLS18Y29udMOpbXwgRVtkYWRvcyBkYW5vc29zXVxuRSAtLS18c8Ojb3wgRTFbaGlww7N0ZXNlcy9wcm9nbsOzc3RpY29zIHF1ZSA8YnI-IG8gcGFjaWVudGUgcG9kZSBuw6NvIHN1cG9ydGFyXVxuQiAtLS18Y29udMOpbXwgRlthdGVzdGFkbyBkZSDDs2JpdG9dXG5CIC0tLXxjb250w6ltfCBHW2xhdWRvIGRlIMOzYml0b11cbkEyW1BhY2llbnRlXSAtLSBpcnJlc3RyaXRvLCBhIG1lbm9zIHF1ZSA8YnI-IGNhdXNlIGRhbm8gPGEgaHJlZj1cIlwiaHR0cDovL2JpdC5seS9Dw7NkaWdvw4l0aWNhTWVkaWNpbmEjYXJ0MzRcIlwiPkFydC4gMzQ8L2E-IC0tPiAgQltQcm9udHXDoXJpb11cbkEzW1JlcHJlc2VudGFudGUgTGVnYWxdIC0tIGlycmVzdHJpdG8gPGEgaHJlZj1cIlwiaHR0cDovL2JpdC5seS9Dw7NkaWdvw4l0aWNhTWVkaWNpbmEjYXJ0MzRcIlwiPkFydC4gMzQuPC9hPi4gLS0-ICBCW1Byb250dcOhcmlvXVxuQTRbRmFtaWxpYXIgZGUgMcK6XSAtLSBpcnJlc3RyaXRvIDxhIGhyZWY9XCJcImh0dHA6Ly9iaXQubHkvMlQ4NWhWTVwiXCI-Q1JFTUVTUDwvYT4uIC0tPiAgRlxuQTQgLS0gaXJyZXN0cml0byBhcMOzcyBvIMOzYml0byA8YnI-PGEgaHJlZj1cIlwiaHR0cHM6Ly9nbG8uYm8vMlQyTDRSaVwiXCI-c2VndW5kbyBhIGp1c3Rpw6dhPC9hPiAtLT4gIEJcbkE0IC0tIGlycmVzdHJpdG8gPGEgaHJlZj1cIlwiaHR0cDovL2JpdC5seS8yVDg1aFZNXCJcIj5DUkVNRVNQPC9hPiAtLT4gIEdcbkE1W1NlZ3VyYWRvcmFdIC0tIGlycmVzdHJpdG8gPGEgaHJlZj1cIlwiaHR0cDovL2JpdC5seS9Dw7NkaWdvw4l0aWNhTWVkaWNpbmEjYXJ0NzdcIlwiPkFydC4gNzcuLjwvYT4uIC0tPiAgRlxuQTUgLS0gIHF1YW5kbyBhdXRvcml6YWRvIHBlbG8gPGJyPiByZXByZXNlbnRhbnRlIGxlZ2FsIDxicj48YSBocmVmPVwiXCJodHRwOi8vYml0Lmx5L0PDs2RpZ2_DiXRpY2FNZWRpY2luYSNhcnQ3N1wiXCI-QXJ0LiA3Ny48L2E-IC0tPiAgR1xuQTZbUGVyaXRvXSAtLSBxdWFuZG8gPGJyPiBub21lYWRvIDxhIGhyZWY9XCJcImh0dHA6Ly9iaXQubHkvQ8OzZGlnb8OJdGljYU1lZGljaW5hI2FydDg5cDFcIlwiPiAmIzE2NyAxwrosIEFydC4gODkuPC9hPiAtLT4gQlxuQTdbUGVzcXVpc2Fkb3JdIC0tIGF1dG9yaXphZG8gcGVsbyBDb21pdMOqIDxicj4gZGUgw4l0aWNhIG91IHBhY2llbnRlIC0tLSBCXG5BOFtUZXJjZWlyb3NdIC0tIGF1dG9yaXphZG8gcGVsbyA8YnI-IHBhY2llbnRlIDxhIGhyZWY9XCJcImh0dHA6Ly9iaXQubHkvQ8OzZGlnb8OJdGljYU1lZGljaW5hI2FydDg5XCJcIj4gJiMxNjcgMcK6LCBBcnQuIDg5LjwvYT4gLS0-IENcbkE4W1RlcmNlaXJvc10gLS0gYXV0b3JpemFkbyBwZWxvIDxicj4gcGFjaWVudGUgPGEgaHJlZj1cIlwiaHR0cDovL2JpdC5seS9Dw7NkaWdvw4l0aWNhTWVkaWNpbmEjYXJ0ODlcIlwiPiAmIzE2NyAxwrosIEFydC4gODkuPC9hPiAtLT4gRCIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0Iiwic2VjdXJpdHlMZXZlbCI6Imxvb3NlIn19}{Link do Diagrama (Ainda vou desenhar isso usando a biblioteca TikZ}

(quando eu refizer esse diagrama, vou incluir o MÉDICO. Esqueci do papel principal, mas já sei que ele tem acesso irrestrito se ele for o responsável pelo paciente)}

{\color{ForestGreen}Explicar que no sistema proposto existe um servidor de atributos ao qual se pedem as chaves públicas/privadas para realizar a encriptação/decriptação (1 parágrafo).}

Atributos são pares de chaves pública e um conjunto de chaves privadas pessoais que possibilitam a criptografia assimétrica. Um atributo precisa ser publicado na blockchain para ser utilizado pelos outros usuários, e considera-se publicado o atributo que tenha seus parâmetros de chave pública enviados ao Smart Contract que gerencia estas chaves. De posse da chave pública é possível criptografar um arquivo com uma política de acesso descrita em termos daqueles atributos e caso o usuário possua as respectivas chaves privadas pessoais também é possível descriptografar o conteúdo cifrado. As operações criptográficas sempre ocorrem localmente para evitar a exposição de informação sensível à rede a qual está conectado.

{\color{ForestGreen}Explicar como é realizado o passo-a-passo para o pedido/entrega das chaves (note que aqui a descrição é muito mais profunda que o que foi mencionado na visão geral) (1 parágrafo).}

O conjunto de chaves privadas pessoais deriva de uma chave privada secreta associada a um atributo público e de posse do certificador que a gerou. Para assegurar a unicidade da chave, também é necessário derivar a chave a partir de um identificador único (ID) associado ao usuário. Utilizar atributos com ID distintos impede a descriptografia de funcionar, assegurando que atributos não sejam intercambiáveis entre os usuários. {\color{RoyalBlue} existe um nome para esse problema onde alguém tentar ceder credenciais para alguém não autorizado. Usar aquela definição aqui}

O mecanismo de derivação de chaves privadas pessoais está atrelado ao processamento de requisições, impedindo o certificador de conceder chaves arbitrariamente, mas somente a partir de requisição prévia. Isso é uma estratégia para limitar o poder do certificador em criar atributos, e dessa forma abusar de sua autoridade para conceder acesso indevido a agentes não autorizados de forma. O certificador portanto consulta a blockchain para obter novas requisições e decide se irá processá-la ou não. Nos dois casos, a resposta retorna à blockchain assim que a chave é criada ou quando sua criação é negada, quer seja por decisão do certificação ou por falha devido a parâmetros incorretos.


\subsection{Contratos inteligentes com CBA}

Foram desenvolvidos cinco contratos inteligentes que permitem a autenticação, entrega de permissões e armazenamento de metadados dos prontuários eletrônicos dos pacientes. A seguir serão explicados cada um deles.

{\color{ForestGreen} Explicação do  SmartDCPABEAuthority (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados.}

{\color{Magenta} 1 parágrafo para explicar o que faz o contrato (em linhas gerais).}

O contrato \emph{Authority} registra na Blockchain as entidades certificadoras disponíveis no sistema, tornando público seu endereço público na Ethereum, associando dados de indentificação e a quantidade de atributos que a entidade já publicou.
o ID usado para derivar as chaves privadas dos atributos no esquema ABE é a chave privada que corresponde à chave pública do Ethereum.
Esse esquema permite que uma entidade possa ser identificável de forma única sem a necessidade de controle centralizada sobre o cadastro de novas unidades.
A escolha do ID visa impossibilitar um atacante de se passar pela entidade certificadora, uma vez que não há método computacionalmente viável para recuperar a chave privada de um endereço Ethereum a partir de uma chave pública.

{\color{Magenta} Inserir o código da linha 7 até 20.}

\lstset{basicstyle=\small, numbers=left, language=bash, keywordstyle=\color{blue}, numbersep=1pt, label={lst:SmartDCPABEAuthority}, caption={Dados em SmartDCPABEAuthority}}
\begin{lstlisting}
 contract SmartDCPABEAuthority is Collection {

 struct Certifier {
   address addr;
   bytes32 name;
   bytes32 email;
   uint64 numPublicKeys;
 }

 address[] public certifierAddresses;
 mapping (address => Certifier) certifiers;
 SmartDCPABEUtility util;
 SmartDCPABEUsers user;
 address contractKeys;
\end{lstlisting}

{\color{Magenta} 1 parágrafo para explicar para que serve CADA UM dos structs, events e atributos. Exemplo. O struct X permite armazenar dados que servirão para Y. O atributo V armazena informações de W que servirão para Z.}

A struct Certifier armazena dados informações da autoridade responsável por publicar atributos e concedê-los a usuários. Além do endereço Ethereum, também é armazenado seu nome, e-mail e a quantidade de chaves que ele já publicou.
Tal unidade de controle é necessária porque as chaves são armazenadas em \emph{mappings}, conforme explicitado na Sessão \ref{sub:sec:contratos-ethereum}.

{\color{ForestGreen} Explicação do  SmartDCPABEKeys (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados.}

{\color{Magenta} 1 parágrafo para explicar o que faz o contrato (em linhas gerais).}

O contrato \emph{Keys} disponibiliza a chave pública de atributos criados por autoridades.
Para fins de prototipagem foram implementadas somente as operação de inclusão e consulta de chaves, mas não de edição ou remoção. Seria trivial implementar isto no Smart Contract, mas não seria trivial e nem viável implementar os protocolos de revogação e substituição de atributos no módulo Cliente, responsável pelas operações criptográficas e pela coordenação das informações entre a Blockchain e o Servidor.

{\color{Magenta} Inserir o código da linha 6 até 24.}

\lstset{basicstyle=\small, numbers=left, language=bash, keywordstyle=\color{blue}, numbersep=1pt, label={lst:SmartDCPABEKeys}, caption={Dados em SmartDCPABEAuthority}}
\begin{lstlisting}
 contract SmartDCPABEKeys is Collection {

 struct PublicKey {
  Bytes127 eg1g1ai;
  Bytes127 g1yi;
 }

 struct Bytes127 {
  bytes32 chunk1;
  bytes32 chunk2;
  bytes32 chunk3;
  bytes31 chunk4;
  uint8 lastChunkSize;
 }

 SmartDCPABEUtility util;
 SmartDCPABEAuthority authority;
 mapping (address => bytes32[]) publicKeyNames;
 mapping (address => mapping (bytes32 => PublicKey)) ABEKeys;
\end{lstlisting}

{\color{Magenta} 1 parágrafo para explicar para que serve CADA UM dos structs, events e atributos.}

a estrutura \emph{Bytes127} foi criada como um container econômico para armazenar os elementos gerados pela biblioteca jPBC \emph{(Java Pairing-Based Cryptography)} \cite{DeCaro2011}.
O tamanho dos elementos varia entre 120 a 124 bytes de informação e, embora o Solidity disponha da estrutura de dados \emph{bytes} para armazenar bytes em tamanho arbitrário, seu custo é maior.
Dados consomem gas, e quando são utilizadas estruturas de dados de tamanho dinâmico, o valor é maior do que suas contrapartes estáticas, justificando a criação de uma estrutura que divida os dados em um conjunto de elementos de tamanho fixo.
A estrutura \emph{PublicKey} armazena a chave pública gerada pela biblioteca \emph{DCPABE}\footnote{código fonte: \href{https://github.com/stefano81/dcpabe}{\texttt{https://github.com/stefano81/dcpabe}}. Para uma análise teórica, ver \cite{Lewko2011}}, que são representadas por duas sequências de bytes como mostra o código.
O mapa \emph{publicKeyNames} mapeia um endereço de uma autoridade a uma lista de nomes de atributos representados como bytes.
O mapa \emph{ABEKeys} contém, para cada endereço cadastrado, um submapa relacionando o nome do atributo representado em bytes com uma chave pública.

{\color{ForestGreen} Explicação do  SmartDCPABEFiles  (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados.}

{\color{Magenta} 1 parágrafo para explicar o que faz o contrato (el linhas gerais).}

{\color{Magenta} Inserir o código da linha 6 até 39.}

{\color{Magenta} 1 parágrafo para explicar para que serve CADA UM dos structs, events e atributos.}


{\color{ForestGreen} Explicação do  SmartDCPABERequests  (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados.}

{\color{Magenta} 1 parágrafo para explicar o que faz o contrato (el linhas gerais).}

{\color{Magenta} Inserir o código da linha 6 até 35.}

{\color{Magenta} 1 parágrafo para explicar para que serve CADA UM dos structs, events e atributos.}


{\color{ForestGreen} Explicação do  SmartDCPABEUsers  (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados.}

{\color{Magenta} 1 parágrafo para explicar o que faz o contrato (el linhas gerais).}

{\color{Magenta} Inserir o código da linha 6 até 16.}

{\color{Magenta} 1 parágrafo para explicar para que serve CADA UM dos structs, events e atributos.}



\subsection{Arquitetura Blockchain}

Como mencionado na Seção \ref{sec:visaogeral}, o sistema é composto por 3 componentes: cliente, servidor, e a Blockchain. A Figura X mostra o relacionamento entre esses componentes.

{\color{ForestGreen} Fazer uma figura simples que mostre os 3 componentes interligados. }


{\color{ForestGreen} Explicar implementação do cliente (5 parágrafos). Ver abaixo os 5 parágrafos destrinchados. }

{\color{Magenta} 1 parágrafo para explicar que para realizar a conexão com a Blockchain usou o web3j (explique em 2-3 linhas o web3j).}

{\color{Magenta} 1 parágrafo para explicar as 3 linhas mais importantes do código fonte de como realizar a conexão. Explicar cada linha do código. }

{\color{Magenta} 1 parágrafo para explicar que para encriptar um documento utilizando atributos usou a dcabe.}

{\color{Magenta} 1 parágrafo para explicar as 3 linhas mais importantes do código fonte de como realizar a encriptação. Explicar cada linha do código.}

{\color{Magenta} 1 parágrafo para explicar as 3 linhas mais importantes do código fonte de como acessar um contrato inteligente. Explicar cada linha do código.}

{\color{ForestGreen} Explicar implementação do servidor (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados. }

{\color{Magenta} 1 parágrafo para explicar que o servidor utiliza REST para prover os serviços via web  (explique em 2-3 o que é REST).}

{\color{Magenta} 1 parágrafo para explicar que o servidor possui o serviço para inserir um documento e para recuperar um documento.}

{\color{Magenta} 1 parágrafo para explicar que o servidor insere e recupera os prontuários eletrônicos de pacientes diretamente do seu sistema de arquivos advindos das requisições web.}


{\color{ForestGreen} Explicar implementação da Blockchain (4 parágrafos). Ver abaixo os 4 parágrafos destrinchados. }

{\color{Magenta} 1 parágrafo para explicar que a Blockchain utilizada foi a testnet (explicar que existe a main e a testnet, onde a testnet é utilizada por desenvolvedores serve para realizar implantações de teste sem dispender recursos financeiros.}

{\color{Magenta} 1 parágrafo para explicar que a rede Blockchain foi implantada em um computador usando o Ganache. Explicar o que é o ganache e o que entrega a implantação (X mineradores? X fullnodes, etc).}

{\color{Magenta} 1 parágrafo para explicar que a Blockchain possui 5 contratos inteligentes mencionados na Seção anterior.}

{\color{Magenta} 1 parágrafo para explicar que a implantação dos contratos inteligentes usou o metamask. Explicar o que é o Metamask e o que especificamente você usou dele: ver identificadores das transações, conversão de .sol para .abi. Explicar o que é .abi.}

% -------------------------------------------------------------------- %
\newpage
\section{Trabalhos Relacionados}

\subsection{Sistemas de saúde com Blockchain e CBA}

\subsection{Sistemas de saúde com CBA}
\label{sub:sec:saude-cba}

\subsection{Sistemas gerais com CBA}

Caso não hajam trabalhos na seção~\ref{sub:sec:saude-cba}.

% -------------------------------------------------------------------- %
\newpage
\section{Resultados Experimentais}



% -------------------------------------------------------------------- %
\newpage
\section{Conclusões e Trabalhos futuros}

gasto financeiro
problema energético
sugestão: hyperledger.

\bibliography{doc}
\bibliographystyle{plainnat}

% -------------------------------------------------------------------- %
\newpage
\section{Anexo I}

PESSOAL DE SAÚDE - NÍVEL SUPERIOR
\begin{enumerate}
    \item ANESTESISTA
    \item ASSISTENTE SOCIAL
    \item BIOQUÍMICO/FARMACÊUTICO
    \item CIRURGIÃO GERAL
    \item CLÍNICO GERAL
    \item ENFERMEIRO
    \item FISIOTERAPEUTA
    \item FONOAUDIÓLOGO
    \item GINECO OBSTETRA
    \item MÉDICO DE FAMÍLIA
    \item NUTRICIONISTA
    \item ODONTÓLOGO
    \item PEDIATRA
    \item PSICÓLOGO
    \item PSIQUIATRA
    \item RADIOLOGISTA
    \item SANITARISTA
    \item OUTRAS ESPECIALIDADES MÉDICAS
    \item OUTRAS OCUPAÇÕES DE NÍVEL SUPERIOR RELACIONADOS À SAÚDE
\end{enumerate}
PESSOAL DE SAÚDE - NÍVEL TÉCNICO TÉCNICO/AUXILIAR
\begin{enumerate}
    \item AUXILIAR DE ENFERMAGEM
    \item FISCAL SANITÁRIO
    \item TÉCNICO DE ENFERMAGEM
    \item TÉCNICO E AUXILIAR DE FARMÁCIA
    \item TÉCNICO E AUXILIAR DE LABORATÓRIO
    \item TÉCNICO E AUXILIAR EM NUTRIÇÃO E DIETÉTICA
    \item TÉCNICO E AUXILIAR EM FISIOTERAPIA E REABILITAÇÃO
    \item TÉCNICO E AUXILIAR EM SAÚDE ORAL
    \item TÉCNICO E AUXILIAR EM VIG SANITÁRIA E AMBIENTAL
    \item TÉCNICO E AUXILIAR EM EQUIP MÉDICO-HOSPITALARES
    \item TÉCNICO E AUXILIAR EM RADIOLOGIA MÉDICA
    \item TÉCNICO E AUXILIAR EM HEMATOLOGIA/HEMOTERAPIA
    \item TÉCNICO E AUXILIAR EM HISTOLOGIA
    \item OUTRAS OCUPAÇÕES NÍVEL TÉCNICO E AUXILIAR EM SAÚDE
\end{enumerate}
PESSOAL DE SAÚDE - QUALIFICAÇÃO ELEMENTAR
\begin{enumerate}
    \item AGENTE COMUNITÁRIO DE SAÚDE
    \item AGENTE DE SAÚDE PÚBLICA
    \item ATENDENTE DE ENFERMAGEM/AUX OPER SERV DIV E ASSEM
    \item PARTEIRA
    \item OUTRAS OCUPAÇÕES NÍVEL ELEMENTAR EM SAÚDE
\end{enumerate}
PESSOAL ADMINISTRATIVO
\begin{enumerate}
    \item ADMINISTRAÇÃO
    \item SERVIÇO DE LIMPEZA/CONSERVAÇÃO
    \item SEGURANÇA
    \item OUTRAS OCUPAÇÕES ADMINISTRATIVAS
\end{enumerate}

\end{document}
