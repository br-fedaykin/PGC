\documentclass[a4paper,11pt]{article}
\usepackage[left=3cm,top=3cm,right=2cm,bottom=2cm]{geometry}
\usepackage[brazilian, english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[numbers]{natbib}
\usepackage{epigraph}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{setspace}
\usepackage[hidelinks]{hyperref}
\usepackage[bottom]{footmisc}
%\usepackage{xcolor}
\usepackage[dvipsnames]{xcolor}
\usepackage{adjustbox}
\usepackage{verbatim}
\usepackage{float}
\usepackage{lmodern}% http://ctan.org/pkg/lm
\usepackage{svg}
\usepackage{xcolor}

% custom link style
\newcommand{\link}[2]{{\color{blue}\underline{\href{#1}{#2}}}}
\newcommand{\tabitem}{~~\llap{\textbullet{\ensuremath{\bullet}}}~~}
\newcommand*{\SignatureAndDate}[4]{%
	\parbox{7cm}{
      \centering
      \rule{6cm}{1pt}
       #1

       #2
    }
    \hfill
\parbox{7cm}{
      \centering
      \rule{6cm}{1pt}
       #3

       #4
    }
}%

\floatstyle{ruled}
\newfloat{program}{thp}{lop}
\floatname{program}{Program}

\onehalfspacing
\setlength{\parskip}{1em}

% table configuration
\setlength{\tabcolsep}{18pt}
\renewcommand{\arraystretch}{1.5}

\title{Relatório de Estágio III}

\renewcommand{\familydefault}{\sfdefault}

% listing label configuration
\renewcommand{\lstlistingname}{Código}
\renewcommand{\lstlistlistingname}{Lista de \lstlistingname s-Fonte}

\begin{document}
\selectlanguage{brazilian}

%%% CAPA %%%

\begin{titlepage}

\begin{wrapfigure}[2]{l}{0.2\textwidth}
	\label{Logo UFABC}
	\vspace{-1\baselineskip}
	\centering
	\includegraphics[width=0.25\textwidth]{images/Logo_UFABC}
\end{wrapfigure}

\uppercase{Universidade Federal do ABC}

\uppercase{Bacharelado em Ciência da Computação}

\vfill
\begin{center}

\uppercase{\textbf{Projeto de Graduação em Computação}}

\vfill

\uppercase{Bruno Cesar Porto de Arruda}
\vspace{1cm}

Orientador: Prof. Dr. Vladimir Moreira Rocha

\vfill

Santo André -- SP

2019
\end{center}
\end{titlepage}

%%% FIM DA CAPA %%%

%%% FOLHA DE ROSTO %%%

\begin{titlepage}
\begin{center}
\uppercase{\textbf{Bruno Cesar Porto de Arruda}}

\vfill

\uppercase{\textbf{Um sistema distribuído com permissão de acesso a prontuários de pacientes por meio de Smart Contracts}}
\end{center}

\vfill

\hfill \begin{minipage}{0.5\textwidth}
Trabalho submetido à Universidade Federal do ABC como parte dos requisitos para a conclusão do Bacharelado em Ciência da Computação.
\vspace{1cm}

Orientador: Prof. Dr. Vladimir Moreira Rocha
\end{minipage}

\vfill

\begin{center}
Santo André -- SP

2019
\end{center}
\end{titlepage}

%%% FIM DA FOLHA DE ROSTO %%%

\begin{center}
\uppercase{\textbf{Dedicatória}}
\end{center}
	xxx.


\newpage
\begin{center}
\uppercase{\textbf{Agradecimentos}}
\end{center}

\noindent	Ofereço meus sinceros agradecimentos:

\vspace{1cm}


%%% ABSTRACT - PORTUGUÊS %%%
\newpage
\begin{abstract}

\noindent FAZER NO FINAL.

\noindent \textbf{Palavras-Chave:} Blockchain; Ethereum; Contratos Inteligentes; CBA.
\end{abstract}

%%% ABSTRACT - INGLÊS %%%

\newpage
\selectlanguage{english}
\begin{abstract}
\noindent FAZER NO FINAL.

\noindent \textbf{Keywords:} Blockchain; Ethereum; Smart Contracts; ABE.
\end{abstract}

\selectlanguage{brazilian}

%%% SUMÁRIO %%%
\newpage
\tableofcontents

%%% LISTA DE CÓDIGOS %%%
\newpage
\lstlistoflistings

%%% LISTA DE FIGURAS %%%
\newpage
\listoffigures

%%% LISTA DE TABELAS %%%

\newpage
\listoftables

% -------------------------------------------------------------------- %
\newpage
\section{Introdução}

A tecnologia Blockchain~\cite{nakamoto2008bitcoin}...

\subsection{Objetivo geral}

Criar um sistema, com base em contratos inteligentes executados em uma Blockchain, que permita o acesso a prontuários eletrônicos dos pacientes via políticas de acesso baseadas em atributos.

\subsection{Objetivos específicos}

\begin{itemize}

\item Criar uma taxonomia de permissões no contexto de saúde.

\item Analisar como funciona a criptografia baseada em atributos (\textit{attribute-based encryption}, em inglês).

\item Analisar como funcionam a tecnologia Blockchain {\color{red}escolher a tecnologia} e os contratos inteligentes.

\item Implementar os contratos inteligentes para dar acesso aos prontuários eletrônicos utilizando a taxonomia e a criptografia baseada em atributos.

\item Implantar e executar os contratos inteligentes em uma arquitetura Blockchain.

\end{itemize}

\subsection{Justificativa}

% -------------------------------------------------------------------- %
\newpage
\section{Fundamentação Teórica}

\begin{itemize}
    \item {\color{red}Cada parágrafo deve ter em torno de 10 linhas}
    \item {\color{red}Não mostrar código.}
\end{itemize}

\subsection{Criptografia baseada em atributos (CBA)} \label{sec:sub:cba}

{\color{ForestGreen}Explicar quando nasceu, quem a criou, e qual foi o problema que estava resolvendo (basicamente que a criptografia chaves publica/privada precisa ser criada para cada usuário que precisa de permissão e com a por atributos não). (2 parágrafos).}

A criptografia assimétrica pode ser vista como um mecanismo para que um usuário, Alice, codifique dados de forma confidencial e o aderece a um destinatário, Bob.
Para que seja viável criptografar um conteúdo desta forma, geralmente é necessário que exista uma Infraestrutura de Chaves Pública \emph{(Public Key Infrastructure - PKI)} para incluir Bob ao sistema, atribuir-lhe uma chave pública de forma aleatória e manter um diretório de certificados com chaves públicas acessível à Alice e demais usuários do sistema para realização de operações de criptografia.
A aleatoriedade na geração de chaves públicas impõe uma restrição de uso quando o destinatário não faz parte do sistema.
Alice só tomará conhecimento da chave pública de Bob quando esta for outorgada pela entidade certificadora e permanece neste meio tempo sem formas de usar o sistema para garantir o sigilo de eventuais informações encaminhadas a Bob.
A necessidade da consulta e validação das chaves públicas no diretório de certificados disponibilizado pela PKI também restringe o uso e disponibilidade da operação de criptografia à disponibilidade de conexão, por algum meio, às fontes disponíveis de consulta.

Visando eliminar tais restrições, Shamir idealizou em 1984 a Criptografia Baseada em Identidades \emph{(IBE - Identity-Based Cryptography)}, um esquema onde as chaves públicas utilizadas para criptografia seriam as próprias formas textuais de identificação de uma pessoa, tais como e-mail, nome completo, números de documento ou qualquer combinação arbitrária destes dados.
Chaves privadas seriam derivadas adicionando à chave pública um parâmetro fixo e secreto, sob controle de uma terceira parte confiável responsável por gerenciar a requisição, geração e entrega de chaves privadas \cite{Shamir1985}.
Foi somente em 2001 que houve a primeira proposta efetivamente segura e prática de um sistema que atendesse as características da IBE, junto com esquemas de uso que possibilitariam mecanismos de revocação automática de usuários e controle de acesso ao embutir na chave pública marcações com um significado definido no contexto de uso do sistema \cite{Boneh2001}.
Por exemplo, ao criptografar e enviar um arquivo usando identidade de Bob concatenada com ano atual (``\emph{ano-2020}''), pode-se conceber um cenário onde Bob devesse solicitar ao gerador de chaves a chave privada correspondente à chave pública ``\emph{Bob@mail.com ano-2020}'', levando a requisições periódicas de novas chaves em anos subsequentes e implementando uma forma efetiva e automática de revocação de acesso de usuários simplesmente ao deixar de conceder novas chaves.
Adicionando tags do tipo ``\emph{acesso=restrito}'' ao exemplo anterior pode-se pensar em um cenário onde o gerador de chaves iria exigir privilégios de acesso ou o aceite de termos de compromisso para conceder a chave privada relacionada a uma chave pública do tipo ``\emph{Bob@mail.com ano-2020 acesso=restrito}''.

A Criptografia Baseada em Atributos (em inglês, \emph{ABE - Attribute-Based Encryption}) visa aumentar a expressividade da IBE ao modelar identidades como um conjunto de atributos, definir chaves públicas como subconjuntos de atributos e tornar a descriptografia possível ao usuário que possuir as chaves privadas correspondentes a estes atributos \cite{Sahai2005}.
Atributos podem ser vinculados a grupos de usuários ou a papéis desempenhados por eles, permitindo expressar políticas de acesso específicas de forma simples e eficaz, sem que seja necessário conhecer a identidade exata de todas as pessoas que deveriam ter acesso aos dados criptografados.
Indivíduos precisariam se autenticar junto a um ente confiável para obter as chaves privadas correspondentes a cada atributo da mesma maneira que ocorre na IBE, e utilizariam estas chaves para cumprir os requisitos da política de acesso e realizar a descriptografia de dados.
É importante que a concessão das chaves privadas relacionadas a um atributo sejam diferentes para cada usuário e preferencialmente sejam
atreladas à identidade do usuário, de forma a não permitir um ataque de conluio \emph{(collusion attacks)}, onde um usuário com atributos ``$A$'' e ``$B$'' e outro com atributos ``$C$'' e ``$D$'' unam suas chaves privadas para satisfazer uma política de acesso que exija ``$A$'' e ``$D$'' \footnote{Subsequente ao trabalho de Sahai e Waters, um trabalho de Juels e Szydlo propôs outra noção para ABE, onde não haveria resistência contra ataques de colusão. Para mais detalhes, ver \cite{Juels2004}.}.

{\color{ForestGreen}Explicar alguns conceitos da CBA (chave pública/privada/etc para que sirva como base do exemplo mostrado no último parágrafo (1 parágrafo).}

As políticas de acesso usadas na ABE são traduzidas em um Esquema de Compartilhamento de Segredo (em inglês, \emph{SSS - Secret Sharing Scheme}), onde os atributos ocupam o papel de participantes do esquema e o segredo a ser reconstruído é parte indispensável para executar o algoritmo de descriptografia.
Qualquer esquema de compartilhamento delineia também alguma estrutura de acesso que defina os subconjuntos de participantes que deveriam ser capazes de reconstruir o segredo a partir de suas partes.
Shamir demonstrou como produzir estruturas de acesso com uma porta de limiar $(k,n)$, permitindo a reconstrução do segredo se $k$ entre os $n$ participantes se unirem e impedindo, para números menores do que $k$, a reconstrução ou qualquer ganho de informações quanto ao segredo \cite{Shamir1979}.
Benaloh expandiu a ideia, descrevendo esquemas eficientes para estruturas de acesso que pudessem ser descritas em termos de fórmulas monótonas, isto é, fórmulas booleanas utilizando operadores lógicos binários $AND$ e $OR$ e os participantes como predicados \cite{Benaloh1988}.
Desta forma a ABE consegue descrever políticas de acesso como fórmulas booleanas e computar de forma eficiente se os atributos apresentados formam um dos subconjuntos de atributos definidos como válidos pela estrutura de acesso, impedindo que atributos não relacionados a uma estrutura de acesso possam ser usados para descriptografar um conteúdo.

% não estou certo deste conteúdo abaixo, então deixei como comentário
% Por conta do uso de esquemas de compartilhamento de segredos em sua operação, é necessário que todos os atributos tenham uma identidade definida e fixa ao logo da execução do programa, e isso impõe uma etapa de inicialização ao esquema ABE onde o universo de atributos são criados, publicando-se seus dados como parâmetros públicos do sistema, e remove do sistema a capacidade de adicionar atributos após inicializado.

As estruturas de acesso descritas anteriormente foram inicialmente construídas e distribuídas como parte das chaves privadas conferidas aos usuários, enquanto que o conjunto de atributos necessários à descriptografia era informado na cifra.
Essa foi a primeira forma de construção de ABE e foi denominada como KP-ABE \emph{(Key-Policy Attribute-Based Encryption)} por definir nas chaves privadas as políticas de acesso que um usuário poderia cumprir e requerer e especificar os atributos na cifra \cite{Goyal2006}.
Posteriormente reverteram essa construção de forma que chaves privadas de usuários fossem conjuntos de atributos e a cifra contivesse a política de acesso e consequentemente a estrutura de acesso subjacente dela. Essa abordagem foi denominada como CP-ABE \emph{(Ciphertext-Policy Attribute-Based Encryption)} \cite{Bethencourt2007}.
Embora sejam contrapartes de uma mesma construção teórica, elas diferem em seu uso, uma vez que a decisão da escrita de políticas de acesso e a consequente decisão sobre quem pode ou não pode descriptografar conteúdos é feita por partes diferentes.
Na KP-ABE a entidade geradora de chaves define as políticas de acesso na emissão de chaves aos usuários, enquanto na CP-ABE as políticas de acesso podem ser escritas conforme a necessidade e o conhecimento específico das informações de um documento pelo usuário que realizará a criptografia.


{\color{ForestGreen}Explicar os benefícios do CBA (2 parágrafos).}

A definição de uma autoridade central para gerar chaves pode representar um problema em um contexto de operação multi-institucional, uma vez que isso exige encontrar uma autoridade que seja confiável entre todas as instituições participantes.
Ademais, uma única autoridade também se configura como um ponto de falha central, levando à suspensão do serviço em caso de problemas técnicos ou ataques de negação de serviço.
Pode-se diluir esse problema ao espalhar o funcionamento do programa entre vários servidores, mas esta medida também expõem os parâmetros secretos de funcionamento do sistema a mais ambientes, aumentando o risco de vazamento de dados.
O esquema DCPABE \emph{(Decentralized Ciphertext-Policy Attribute Based Encryption)} oferece as vantagens de uma arquitetura descentralizada, buscando resolver o problema da centralização ao propor uma plataforma com multi-autoridades com esquemas ABE independentes que podem ser criadas e operar sem necessidade de qualquer coordenação, além do uso de um mesmo conjunto de parâmetros iniciais de configuração \cite{Lewko2011}.

\begin{figure}[!h]
  \centering
  %\includesvg{images/diagrama-DCPABE.svg}
  \includegraphics[width=\textwidth]{images/diagrama-DCPABE.png}
  \caption{Um esquema DCPABE com K autoridades e exemplo de geração de chaves pessoais a usuários}
  \label{fig:diagramaDCPABE}
\end{figure}

A figura \ref{fig:diagramaDCPABE} descreve os principais elementos que compõem o esquema DCPABE e a geração de chaves a dois usuários do sistema, Alice e Bob.
Qualquer participante pode se tornar uma autoridade e criar atributos, gerando para cada atributo uma chave pública e uma chave privada, esta última usada para gerar chaves pessoais e intransferíveis aos usuários do sistema.
Esse sistema suporta a escrita de políticas de acesso usando atributos emitidos por diferentes autoridades, tornando-se atrativo como a base fundacional de um sistema de integração criptograficamente seguro.
A fim de impedir ambiguidades, a chave pública é considerada a concatenação de seu nome e valor, possibilitando a diferenciação entre dois atributos de mesmo nome gerados por entidades distintas, impedindo também ataques do tipo \emph{spoofing}\footnote{Em um ataque de \emph{Spoofing} um atacante tenta }.
Para impedir ataques de colusão por parte dos usuários a geração das chaves é feita usando um identificador global \emph{(GID)} de usuário, que é utilizado para "vincular" os atributos de diferentes autoridades a um mesmo usuário.
Este identificador GID é um parâmetro adicional usado durante o processo de verificação da satisfazibilidade da estrutura de acesso no mecanismo e descriptografia e assegura o fracasso da criptografia quando atributos emitidos com identificadores globais distintos forem utilizados em conjunto para satisfazer uma política de acesso, em complemento ao comportamento padrão da ABE que impede a criptografia caso não exista um subconjunto entre os atributos apresentados que satisfaça a estrutura de acesso subjacente à política de acesso.

{\color{ForestGreen}Explicar um exemplo de uso (1 parágrafo). Pode usar algo assim: https://medium.com/asecuritysite-when-bob-met-alice/towards-true-security-attribute-based-encryption-20d5799aeda6}

Com a DCPABE pode-se finalmente integrar com segurança bases de dados distintas sob controle de entidades separadas.
Por exemplo, suponha que um serviço de consulta de dados médicos de pacientes entre múltiplos hospitais use um esquema DCPABE.
Isso permitiria que hospitais criassem seu próprio esquema ABE com sua própria declaração e concessão de atributos.
Criptografar os dados assegura o sigilo da informação, simplificando a implantação e manutenção de serviços Web de consulta aos dados.
Neste cenário, suponha que um centro de emergência receba um caso de um paciente em estado grave com identidade mas inconsciente.
Rapidamente, o centro utiliza o sistema de consulta para obter mais dados deste paciente, e alguns hospitais confirmam possuir dados dele.
Os dados informam cifras diferentes, mas sempre permitindo o acesso a quem possuir um atributo ``\emph{emergência}''.
Este centro médico negociou o recebimento de uma chave pessoal deste atributo ``\emph{emergência}'' que foi concedida pelos hospitais individualmente, e desta maneira ganha o acesso ao prontuário.
Para evitar uma forma contínua de acesso irrestrito ao prontuário os hospitais poderiam adicionar este atributo ``\emph{emergência}''  sob demanda específicas de dados de um paciente e retornar à política anterior após a alta médica.

\subsection{Blockchain Ethereum}

{\color{ForestGreen}Explicar quando nasceu, quem a criou e que resolve o problema de não estar atrelada somente a transações financeiras, tendo um uso mais abrangente para qualquer domínio de aplicação. (2 parágrafos).}

Sistemas de pagamentos virtuais surgiram para atender a necessidade do comércio à distância através da internet, e até recentemente esses sistemas estiveram sob custódia exclusivamente de instituições financeiras vistas como entidades confiáveis para a transação de pagamentos eletrônicos.
Neste modelo centralizado, uma autoridade considerada confiável é encarregada da manter a corretude de um sistema, processando as transações dos usuários e rejeitando tanto transações impossíveis (e.g. transações com data passada, saldo negativo ou outros parâmetros incorretos), quanto transações que, embora formalmente válidas, levariam a inconsistências (e.g., transações com gasto duplo).
Sistemas de pagamentos virtuais operam sobre uma ou mais moedas fiduciárias, cada qual sendo emitida pelo sistema bancário de seu país de origem e cuja gestão e controle máximos estão, via de regra, nas mãos de um Banco Central.
Também é atribuído ao sistema bancário a posição de confiança para emissão da moeda, julgando que ele seja imparcial em sua política de expansão ou retração monetária, provendo a liquidez necessária para o mercado
\footnote{Certas escolas de pensamento econômico como a Escola Austríaca \cite{Mises1960, Rothbard2013} criticam a existência de moedas de curso forçado e existência de um Banco central, enquanto defendem a criação e uso de moedas privadas de uso espontâneo. As criptomoedas se tornaram exemplos inesperados desta ideia.}.
Juntamente com corretoras de valores, o sistema bancário e os sistemas de pagamentos eletrônicos são as bases operacionais do mercado financeiro, permitindo o fluxo de capital entre agentes econômicos em escala nacional ou internacional, tornando viável o sistema financeiro mundial como o conhecemos.

Qualquer sistema baseado em confiança tem fragilidades intrínsecas à sua natureza centralizada tais como o abuso hierárquico da autoridade pela imposição de regras arbitrárias, possivelmente invasivas, desnecessárias e ineficientes, a exposição indiscriminada de informações particulares aos membros das autoridades julgadas particulares, a possibilidade de manipulação de transações e taxas do sistema para proveitos particulares e, em um contexto comercial, devido a exigências legais instituídas amplamente que preveem o direito ao estorno de pagamentos, acaba-se introduzindo a possibilidade de perdas permanentes a prestadores de serviços irreversíveis ou produtos perecíveis, abrindo margem para que fraudadores utilizem tais mecanismos para aplicar golpes e obter bens e serviços sem pagar por eles, principalmente em casos onde a mediação de disputas é ineficiente em apurar as reivindicações ou adota um viés que desfavorece o comerciante
\footnote{Veja algumas notícias relacionadas a fraudes \link{https://canaltech.com.br/e-commerce/golpe-pedra-mercado-livre-115288/}{neste}, \link{https://www.techtudo.com.br/noticias/2019/07/golpe-da-compra-falsa-faz-vitimas-no-mercado-livre-veja-como-evitar.ghtml}{neste} e \link{https://www.coindesk.com/how-fraud-sunk-bitcoin-exchange}{neste} link}.
Uma moeda com pagamentos irreversíveis poderia anular o risco de fraude deste tipo, reduzir os custos e estabelecer contratualmente os mecanismos de mediação necessários em caso de disputa.

O \emph{Bitcoin}
\footnote{O termo Bitcoin é utilizado para se referir à unidade de valor utilizada nas transações, à rede de processamento formada pela execução de seu programa e a seus protocolos e tecnologias subjacentes tais como o código e software oficiais.
Desta forma, o sentido do termo pode variar entre moeda, sistema, rede, programa e até plataforma no caso dos sistemas que o utilizem como tal.}
surge como a primeira alternativa viável de uma rede descentralizada ponto-a-ponto de pagamentos que não depende de uma entidade central confiável.
A confiança é depositada aos próprios integrantes da rede de processamento, através de um conjunto de algoritmos e incentivos que, uma vez postos em funcionamento, conseguem produzir o registro válido e imutável das transações, sob a premissa de que a maior parte dos membros da rede não estejam coordenados em um ataque para alterá-lo \cite{nakamoto2008bitcoin}.
Mais importante do que processar pagamentos, o Bitcoin revelou-se um experimento útil para demonstrar a viabilidade de uma ferramenta sem precedentes denominada como \emph{Blockchain}, por meio da qual o consenso distribuído pôde ser obtido.
Já há milhares de soluções
\footnote{Em 13 de novembro de 2019, há mais de 4.700 projetos registrados no \link{https://coinmarketcap.com/}{CoinMarketCap} e mais de 6.100 no \link{https://coinlib.io/}{coinlib}, dois dos maiores sites agregadores de informações do mercado de criptomoedas.}
baseadas em Blockchain, que se tornaram conhecidas como \emph{criptomoedas}, embora nem todas elas tenham o objetivo de serem utilizadas primariamente como um sistema de pagamentos, como é o caso da plataforma \emph{Ethereum}, utilizada nesse trabalho.
Entender o conceito de Blockchain é um passo necessário para compreender os fundamentos da mecânica de funcionamento da rede \emph{Ethereum}.

{\color{ForestGreen}Explicar o que é (distributed ledger, cadeia de blocos, transação) e suas características (anonimato, imutabilidade, distribuição). (2 parágrafos).}

Em seu cerne, a Blockchain é uma estrutura de dados com suporte somente à inserção de novos elementos, encadeados por referências ao hash de seu conteúdo, levando portanto a uma quebra da estrutura no ponto em que um elemento foi modificado, impedindo que a modificação passe despercebida e produzindo a propriedade de imutabilidade aos dados, na medida da segurança da função de hashing utilizada.
Essa estrutura originalmente foi concebida como uma forma de impor uma ordem cronológica a documentos digitais sem depender da integridade do provedor deste serviço e preservando a privacidade de seus conteúdos \cite{Haber1991}.
A Blockchain é composta por blocos, onde cada um deles referencia o bloco que o antecede, de forma recursiva, até que exista a referência a um bloco especial que inicia essa sequência, denominado como \emph{Bloco Genesis}.
Um bloco é organizado em um cabeçalho e um corpo.
O cabeçalho armazena informações relevantes para a verificação de sua integridade, contendo dados como o hashing do bloco anterior, da árvore Merkle das transações no corpo do bloco, um hashing do próprio cabeçalho, e metadados relevantes como versão do protocolo e parâmetros utilizados para o algoritmo de consenso.
A Figura \ref{fig:blockchain} demonstra essa estrutura.

\begin{figure}[htp]
    \centering
    \includegraphics[width=\textwidth]{images/exemplo-de-blockchain.png}
    \caption{Estrutura básica de uma Blockchain}
    \label{fig:blockchain}
\end{figure}

Satoshi Nakamoto projetou a Blockchain do Bitcoin para atender as necessidade de uma moeda, contudo o protocolo extrapola essa finalidade, suportando operações mais complexas, além do simples escopo de um sistema de pagamentos.
Isto porque, ao invés de implementar uma lista preemptiva e exaustiva de todas as transações que pudessem vir a ser necessárias, o protocolo do Bitcoin descreve as transações em termos de comandos de uma linguagem de script baseada em pilha, intencionalmente turing-incompleta, sem loopings ou recursividade, contendo algumas operações aritméticas, lógicas e criptográficas julgadas úteis para oferecer maior liberdade na modelagem de transações que a rede viria a suportar \cite{Narayanan2016a}.

%que impedirá o uso de transações que não o resolvam corretamento e reconhecerá como legítima a transação que a resolver

A transação é a unidade elementar da Blockchain e em sua estrutura possui um cabeçalho contendo metadados e duas listas, denominadas somente como "entradas" e "saídas", que indicam respectivamente de que transação estão vindo os fundos sendo consumidos e qual será a sua destinação.
Uma saída na lista de saídas especifica uma quantidade em bitcoins e usa um script para 'trancar' este valor sob um desafio criptográfico descrito em termos do script do Bitcoin.
Uma entrada na lista de entradas contém uma referência a uma saída específica da lista de saídas de uma transação e um script que "resolve" o desafio relacionado àquela saída.
A checagem de uma transação se dá pela união e execução dos scripts de entrada e saída pelo cliente do Bitcoin, que é considerada válida se, e somente se, para cada elemento da lista de entradas, a execução conjunta dos scripts de entrada e saída resultar em um estado válido, que é definido pelo protocolo como a situação onde, ao fim da execução do script, a pilha de execução do interpretador contar somente com a instrução definida como o valor VERDADEIRO
\footnote{O artigo \cite{Bistarelli2019} ilustra o estado da pilha de um interpretador durante execução de scripts Bitcoin passo a passo.}.
Qualquer outro estado ao final da execução de qualquer um dos elementos de entrada a tornará uma transação inválida e nesta situação será descartada pelos nós da rede Bitcoin que por ventura a receberem.

A linguagem de Script do Bitcoin modela o comportamento das transações e pode ser copiada e reusada em outras transações de mesma natureza.
O script mais utilizado na Blockchain foi chamado de P2PKH \emph{(Pay to Public Key Hash)} e modela uma transação de transferência de moeda Bitcoin entre duas carteiras.
O P2PKH especifica um hash de uma chave pública na saída de uma transação, condicionando a utilização do valor à apresentação da chave pública que corresponda ao hash, juntamente com uma assinatura produzida pela chave privada da respectiva chave pública, permitindo que somente o detentor da chave privada possa utilizar o valor encaminhado a ele por meio da chave pública.
Outros scripts juntamente com este formam um pequeno conjunto de scripts creditados como seguros e alçados ao status de padrão no protocolo do Bitcoin.
Uma transação é considerada padrão quando só utiliza scripts padrões, e mais de 99,9\% das transações na Blockchain são padrões \cite{Bistarelli2019}.
A alta adesão não é coincidência, pois o cliente oficial do Bitcoin não permite a propagação de transações não-padrão pela
rede
\footnote{
Não é relevante descrever aqui todas as restrições e validações de transações. É possível ver a lista completa na página da \link{https://en.bitcoin.it/wiki/Protocol_rules\#.22tx.22_messages}{Bitcoin Wiki}},
virtualmente negando o serviço a transações deste tipo, impondo ao seu proponente o ônus de propagar sua transação de forma externa à rede na tentativa de fazê-la alcançar os nós que tenham a eventual chance de incluir um bloco na Blockchain.

Essa linguagem de script demonstra a preocupação desde o projeto do Bitcoin para abarcar, caso fosse necessário, complexidades e regras de transação para além do escopo de uma moeda ou de um sistema de pagamentos, tornando viável projetar por em prática transações de calção, execução de vínculos contratuais, mecanismos de arbitragem privada e transações com multi-assinaturas.
As possibilidades se expandiram no início de 2014 \cite{Greenspan2015} com um \emph{Hard Fork}
\footnote{Hard Fork é uma atualização no protocolo Bitcoin sem compatibilidade com as versões anteriores e que obriga a atualização do software para uma versão compatível com o novo formato dos dados na Blockchain.}
que passou a permitir a adição de até 80 bytes de metadados arbitrários em uma transação, abrindo o caminho, mesmo que limitado, para a utilização da blockchain como um \textbf{livro-razão distribuído} (em inglês, \textbf{\textit{Distributed Ledger}}), isto é, uma fonte de dados onde seria possível registrar informações públicas, perenes e inalteráveis com alta disponibilidade e acessibilidade.
A \emph{Blockchain 2.0} surge para avançar o suporte a este conceito de livro-razão distribuído, trazendo novas tecnologias baseadas em blockchain, destacando-se as \emph{Smart Properties}, \emph{Smart Contracts} e \emph{DApps (Decentralized Applications)} \cite{Swan2015}.
Essas ferramentas elevam a expressividade e capacidade da Blockchain como uma plataforma para a criação de aplicações financeiras, semi-financeiras, e até mesmo aplicações com ativos que não são financeiros.

%% detalhamento do Bitcoin além do escopo do trabalho removido do texto
% O Bitcoin permite à princípio scripts com tamanho de até 10 mil bytes e com dados de no máximo 520 bytes na pilha de execução\footnote{Informações retiradas do cliente oficial do Bitcoin, versão 0.19, no arquivo de cabeçalho referente a scripts, linhas {\color{RoyalBlue}\href{https://github.com/bitcoin/bitcoin/blob/0.19/src/script/script.h\#L23}{23}} e {\color{RoyalBlue}\href{https://github.com/bitcoin/bitcoin/blob/0.19/src/script/script.h\#L32}{32}}.}.

{\color{ForestGreen}Explicar que para criar o consenso, ou seja, escolher quem irá inserir o último bloco na cadeia, é necessário utilizar o mecanismo de consenso denominado Proof-of-Work (PoW). Explicar em que consiste o PoW. (2 parágrafos).}

\begin{figure}[!h]
  \centering
  \includesvg{images/taxonomia-blockchains.svg}
  %\includegraphics[width=\textwidth]{images/diagrama-DCPABE.png}
  \caption{Taxonomia de Blockchains quanto ao acesso à rede e diferenciação de usuários}
  \label{fig:taxonomiaBlockchains}
\end{figure}

Uma rede Blockchain pode ser configurada como pública ou privada e
pode exigir ou não permissão de entrada, formando uma taxonomia ilustrada na figura X.
Uma Blockchain pública disponibiliza seus dados de maneira irrestrita, bastando que o interessado execute o programa para receber os dados difundidos pela rede, sendo o modelo usado em muitas criptomoedas, a exemplo do Bitcoin e Ethereum.
Em decorrência de sua estrutura descentralizada, os projetos de criptomoedas carecem de uma autoridade central para verificar e autenticar usuários e por isso operam em um modelo sem permissão \emph{(permissionless)}, onde qualquer pessoa pode adicionar nós à rede de processamento.
Redes Blockchain públicas são tratadas como sinônimo de redes sem restrições de acesso e de fato até o momento não há menção de alguma rede do tipo que implemente restrição de acesso
\footnote{Ruiz\cite{Ruiz2020} propõe uma noção diferente para Blockchains públicas e discute sobre a viabilidade a aplicabilidade deste tipo de rede.}.

Uma Blockchain privada é propriedade de uma instituição ou um consórcio delas com a intenção de incorporar suas vantagens à infraestrutura do setor privado.
Para implantar uma Blockchain privada, pode-se configurar um software da criptomoeda mais apropriada aos requisitos de uso para funcionar em uma rede interna e fechada, ou utilizar arquiteturas desenvolvidas propriamente para este fim, como o Hyperledger Fabric ou Hyperledger Besu \cite{Blummer2019}.
Blockchains privadas são uma opção viável quando instituições sem confiança entre si desejam interagir ou integrar suas bases dados e ao mesmo tempo não estão dispostas a concordar com uma terceira parte confiável para intermediar a operação deste sistema \cite{OLeary2017, Wust2017}.
O conjunto de participantes é controlado e conhecido, permitindo o uso de identidades para gerenciar permissão de escrita na Blockchain.
A leitura de dados pode ser restrito aos participantes ou tornado público, caso haja partes interessadas em conduzir uma verificação da validade dos dados armazenados (e.g., clientes ou auditores) .

A Blockchain do Ethereum e outras criptomoedas operam uma arquitetura p2p e foram projetadas para operar sem a premissa de poder contar com usuários confiáveis para realizar operações sensíveis à rede.
A inexistência de um papel fixo para gerenciar o registro de usuários implica na necessidade de tornar a entrada à rede pública e irrestrita e sem esse controle não é mais possível derivar propriedades de segurança acerca da proporção esperada de usuários que possam ser mal intencionados.
Além do mais, a ausência de diferenciação entre usuários implica em um sistema com homogeneidade de papeis, i.e, um sistema onde todos podem realizar o armazenamento, leitura, escrita e atualização e distribuição dos dados da Blockchain.
A viabilidade da rede depende da correta coordenação entre os usuários em meio a um número desconhecido de usuários desonestos dispostos a subverter a ordem do sistema, formando um cenário equivalente ao descrito na literatura como o Problema dos Generais Bizantinos \cite{Lamport1982}.

É necessário um algoritmo de consenso que coordene as alterações realizadas e estabeleça a frequência em que estas alterações devem ocorrer para que o consenso se propague entre todos os usuários da rede.

O algoritmo de consenso do Ethereum em seu cerne é o mesmo do Bitcoin e resolve esse problema de maneira distinta às soluções presentes na literatura.
O algoritmo de consenso organiza a escrita na blockchain em rodadas, estabelecendo um desafio computacional com uma dificuldade ajustada dinamicamente de acordo com a capacidade de processamento total da rede para que se leve, em média, o mesmo período de tempo para produzir blocos.
A participação desse desafio denomina-se mineração, e os usuários realizando mineração são chamados de \emph{minerador}.
A mineração é uma atividade opcional aos usuários, que podem abrir mão desta tarefa ao configurar seu software para operar no modo \emph{Light node}, somente obtendo dados da rede e realizando a verificação e redistribuição.

O desafio computacional se baseia na ideia do HashCash \cite{Back2002} e foi denominada como \emph{Proof-of-Work} \emph{(PoW)}.
Esse algoritmo estabelece o direito de inserir um bloco na Blockchain para quem apresentar um bloco válido, i.e., um bloco constituído somente por transações válidas e cujo cabeçalho contenha uma solução válida para o PoW.
Uma solução válida para o PoW consiste em um hash cujo valor seja precedido por uma quantidade de zeros de acordo com a dificuldade de mineração estabelecida naquele momento.
A mineração é adversarial uma vez que todos os mineradores estão ao mesmo tempo tentando propor o próximo bloco, e não se sabe quem será o próximo responsável por alterar o estado da Blockchain.

Usuários devem enviar aos outros pares conectados a solução válida de um bloco que serão recebidas, verificadas e redistribuídas até que atinja toda a rede conectada.
A distribuição do novo bloco e sua referência em novas propostas de blocos são o consenso da rede de que ele realmente participa da Blockchain.
Por isso pode-se dizer que o consenso ocorre \textbf{implicitamente}, ou seja, não há coordenação de mensagens para desencadear um processo de decisão formal para que um determinado bloco seja aceito ou rejeitado.
Ao invés disso, o consenso se dá pela inclusão, por meio de sua referência, na cadeia de blocos.

\subsection{Contratos inteligentes no Ethereum} \label{sec:sub:contratos-ethereum}

{\color{ForestGreen}Explicar para que servem e listar benefícios. (1 parágrafo).}

O conceito de \emph{Smart Contract} antecede o advento da blockchain, vislumbrando a possibilidade de tornar um acordo formal (i.e., um contrato) firmado entre duas ou mais partes em um conjunto de regras computáveis que podem ser, portanto, embutidos no software ou hardware de propriedades com valor e que são controladas por meios digitais, com protocolos estabelecidos para que as partes possam interagir com as regras e desempenhar seus papéis.
Isso possibilita a execução automática do contrato sem a necessidade de intermediários, reduzindo a necessidade de confiança em terceiros e os custos de transação \cite{Bartoletti2019, Szabo1996}.
O Ethereum foi o primeiro e mais bem-sucedido projeto baseado em Blockchain voltado especificamente para a execução de Smart Contracts, fornecendo uma linguagem de programação turing-completa com suporte a funções criptográficas e de consulta de metadados da blockchain, permitindo expressar contratos na forma de programas que podem ser publicados na rede Ethereum e com os quais usuários e outros contratos podem interagir.

Invocações às funções de um contrato se dão por meio de uma transação contendo, entre outros parâmetros, os argumentos para a execução da função e um limite computacional compulsório a esta execução, expresso em termos de um recurso quantitativo denominado \emph{gas}.
O gas é a unidade fundamental do custo computacional na rede Ethereum, é convertido automaticamente a partir do \emph{Ether} --- a moeda base do Ethereum --- e a taxa de conversão é governada por uma equação definida no protocolo da plataforma, levando em conta estatísticas de uso da rede e ajustando o preço da computação de acordo com a demanda registrada na blockchain.
O usuário pode configurar na transação o quanto de gas deseja utilizar, desde que possua o respectivo saldo em Ether, até um limite máximo atribuído pelo próprio protocolo.
Essa mecânica incentiva um uso consciente da capacidade computacional da rede, contorna o problema da indecibilidade quanto ao fim ou não da execução de um programa, impedindo a parada da \emph{Ethereum Virtual Machine (EVM)} diante da execução de funções que, sem tal limitação, ao rodar indefinidamente ou por períodos extensos poderiam perturbar a taxa com que são processadas novas transações, e por fim serve para proteger os recursos do próprio usuário ao interagir com uma função de um Smart Contract cujo custo esteja além da expectativa, quer seja este custo inerente à função (devido à complexidade da operação) ou só produto de um código ineficiente ou mesmo incapaz de terminar.

{\color{ForestGreen}Explicar que a linguagem utilizada é denominada Solidity. Explicar o que é solidity. (1 parágrafo).}

A linguagem na qual Smart Contracts são publicados na rede Ethereum se chama \emph{Ethereum Virtual Machine code (EVM code)} --- uma linguagem de baixo nível baseada em pilhas, similar à linguagem \emph{Forth}.
Visando ampliar o acesso à tecnologia, a Fundação Ethereum desenvolveu também linguagens de programação de alto nível, com sintaxes similares às linguagens mais utilizadas no mercado, com compiladores para produzir EVM code a partir delas. O \emph{Solidity} é uma destas linguagens, com sintaxe similar a Java e C\texttt{++}, dispondo de um compilador com parâmetros configuráveis e um crescente ecossistema composto por padrões de desenvolvimento, bibliotecas e ferramentas de desenvolvimento\footnote{Para se inteirar do ecossistema Solidity, veja \href{https://github.com/bkrem/awesome-solidity}{https://github.com/bkrem/awesome-solidity} ou outras listas publicadas na internet. Entre as bibliotecas, destacam-se a \emph{\href{https://openzeppelin.com/}{OpenZeppelin}}, \emph{\href{https://github.com/dapphub/dappsys}{Dappsys}} e \emph{\href{https://github.com/modular-network/ethereum-libraries}{Modular Libraries}} por atualmente possuírem as maiores bases de usuários, segundo o site \emph{GitHub}.}, destacando-se o ambiente de desenvolvimento e implantação de Smart Contracts \emph{Remix}, utilizada para codificar, depurar e implantar os Smart Contracts do protótipo deste trabalho em redes de teste Ethereum.

{\color{ForestGreen}Explicar o código de um contrato simples que terá o atributo idPaciente, um map de urls de registros médicos e um método addUrl. (1 parágrafo). Explicar que esse contrato é escrito em um arquivo com extensão .sol}

Com Solidity é possível descrever tanto funções quanto estruturas de dados temporárias ou armazenadas na blockchain.
A coleção de dados armazenados na Blockchain compõe o que se denomina como estado da EVM. A Lista \ref{cod:exemploSmartContract} contém um exemplo de uso de Solidity, implementando um contrato que disponibiliza o acesso de resultado de exames a pacientes.

\lstset{basicstyle=\small, numbers=left, language=bash, keywordstyle=\color{blue}, numbersep=1pt, label={cod:exemploSmartContract}, caption={Exemplo de Contrato Inteligente}}
\begin{lstlisting}
 pragma solidity ^0.5.1;
 pragma experimental ABIEncoderV2;

 contract Hospital {

   enum CodigoResultado {negativo, positivo, inconclusivo, falha}

   struct Registro {
     int version;
     CodigoResultado resultado;
     string data;
     uint MinTime;
     uint MaxTime;
     string extHash;
   }

   mapping (string => Registro) registros;
   mapping (address => string[]) patientURLs;

   function addURL (address patient, string  memory url, Registro memory r) public;
   function getRegistro(string memory url) public view returns (Registro);
  }
\end{lstlisting}


{\color{ForestGreen}Explicar um exemplo passo-a-passo (Só TEXTO, Não Código) de um cliente que obtém o contrato do parágrafo anterior e o executa remotamente em uma máquina. (2 parágrafo).}

As funções implementadas no contrato apontam a existência de dois tipos de papeis relacionados, um que provê informações e outro que as consulta. O Smart Contract armazena duas tabelas, uma associando endereços a uma lista de URLs e outra associando um URL a um objeto do tipo Registro, que contém as informações de um exame. Essas tabelas são alimentadas por meio da função \emph{addURL} do contrato, sendo utilizada pelo Hospital que deseja disponibilizar os exames para consulta, e os exames podem ser consultados usando-se a função \emph{getRegistro}. Ambos os papeis necessitam possuir uma identidade na blockchain Ethereum, ou seja, possuir um endereço válido e ser capaz de publicar transações. Também é necessário possuir um cliente capaz de se conectar a rede para poder publicar novas transações. Já para a consulta de dados, é possível utilizar serviços Web de terceiros, como sites de visualização de transação, para resgatar uma atualização particular ou obter o estado atual das variáveis do contrato.

Este exemplo, embora introduza a sintaxe do Solidity, também incorre em três situações problemáticas que podem precisar de conserto. Primeiro, Smart Contracts tem seu código tornado público à rede no momento de sua implantação e suas funções podem ser utilizadas por qualquer usuário da rede. A ausência de controle no uso da função é um risco à integridade dos dados, uma vez que pode estar sujeita a alterações maliciosas. Um contrato deve impor uma política de acesso a funções sensíveis, implementando nestas funções verificações internas do endereço responsável pela interação, permitindo ou não a execução de acordo com tal política. Segundo, dados publicados na Blockchain são sempre públicos em sua visibilidade, embora possam ter diferentes escopos de acesso. Isso quer dizer que os dados relacionados aos exames serão públicos, expondo informações privativas a quem tiver acesso à Blockchain. Uma maneira de mitigar este problema e ainda assim manter a segurança da informação é publicar assinaturas dos dados, que não conterão informação sensível mas ainda servirão para verificar a integridade e imutabilidade dos dados armazenados externamente, na web. Terceiro, mesmo que não configurasse problema de privacidade, este uso da Blockchain tornaria o custo de operação muito alto, uma vez que a cada exame médico haveria um custo para armazenar múltiplas informações, sendo as mais caras as informações de tamanho dinâmico como a variável de texto \emph{data}. Embora o exemplo exemplifique uma estrutura de dados, na prática a Blockchain tem restrições computacionais de uso baseada no alto custo de armazenamento e processamento, o que significa que mesmo em um cenário onde não seja necessário a privacidade, ainda assim há um incentivo para esvaziar as estruturas de dados de informação relativa ao domínio de aplicação e ao invés disso utilizar ela somente como um meio para se verificar estes dados que estarão alocados em bases de dados externas à Blockchain.


% -------------------------------------------------------------------- %
\newpage
\section{Sistema Proposto}

\begin{itemize}
    \item {\color{red} Assuma nesta seção que os conceitos de blockchain, Ethereum, contratos inteligentes e criptografia baseada em atributos já foram definidos e explicados.}

    \item {\color{red}Cada parágrafo deve ter em torno de 10 linhas}

    \item {\color{red}Não mostrar código.}

\end{itemize}

\subsection{Visão Geral}
\label{sec:sub:visaogeral}

{\color{ForestGreen}Explicar que o sistema é composto por X componentes (1 parágrafo).}

A arquitetura do protótipo é constituída por 3 módulos: um módulo Cliente, que é o maior módulo, destinado para o uso tanto de autoridades quanto de usuários, responsável por coordenar e integrar os demais módulos do sistema, incluindo os Smart Contracts implantados na EVM.
O módulo cliente também oferece a funcionalidade de realizar operações criptográficas no esquema ABE e conexão com a Blockchain Ethereum.
O módulo Blockchain se refere aos Smart Contracts, operando de forma autônoma e contínua na Blockchain, possuindo alguma lógica de aplicação embutida, a maior parte dela para a verificação de que os dados não caracterizam uma transação inconsistente.
Um terceiro módulo servidor armazena e faz a distribuição de arquivos criptografados pelo cliente.

{\color{ForestGreen}Explicar a função de cada componente (1-2 parágrafos para cada um).}

O módulo cliente é responsável por definir a lógica de funcionamento da aplicação, coordenando a atividade dos demais componentes.
Ele acumula funcionalidades que atendem tanto a usuários do sistema, quanto a autoridades que outorgam atributos.
Isso ocorre porque parte da lógica das políticas de acesso considera que o próprio cliente possa criar os próprios atributos e concedê-los a terceiros.

O módulo do servidor recebe, armazena e envia arquivos criptografados, operando como um serviço Web público na internet.
A modelagem deste módulo foi feita considerando um ambiente não-seguro de armazenamento dos dados e em consequência disto, o cliente não envia dados sem estarem criptografados e não é necessário que o servidor armazene metadados de usuários para a identificação de seus dados, bastando apenas armazenar uma código que funcionará como uma chave-primária para a identificação e recuperação de um arquivo em seu sistema de arquivos.
Cabe ao cliente solicitar este código antes do envio, publicá-lo na Blockchain e informá-lo em uma requisição de um arquivo do servidor.
Durante o desenvolvimento e experimentação este mesmo módulo armazenou, de forma temporária, as chaves pessoais de atributos gerados para usuários, mas isso de forma alguma é um requerimento desta solução.
Estas chaves podem ser transferidas de maneira externa ao sistema, pela via que for considerada segura por ambos usuário e certificador, tais como mídia física, serviço de e-mail criptografado ou serviços de armazenamento em nuvem.

O módulo blockchain é responsável por armazenar de forma permanente e imutável o registro de documentos cifrados e a respectiva política de acesso ao documento, descrita em termos de uma forma booleana composta por funções lógicas E e OU com atributos como predicados.
A Blockchain utilizada para teste do protótipo durante o protótipo foi uma versão privada da rede Ethereum gerada e processada por um programa específico para este fim denominado como Ganache.
A necessidade de impor verificações de validade de uma transação e de possuir variáveis com estados exigiu a adoção de Smart Contracts, tornando o Bitcoin uma opção inviável para este trabalho.
Embora seja a rede mais segura e bem-sucedida em termos de desenvolvimento, a rede Ethereum demonstra ser uma melhor opção porque suporta nativamente a execução de Smart Contracts e porque é o projeto mais bem-sucedido entre as opções que envolvem Smart Contracts ao se considerar o tamanho da comunidade envolvida no desenvolvimento e sua posição de mercado em relação aos demais projetos de mesma finalidade.

A biblioteca Web3j foi utilizada neste trabalho para fornecer conectividade à Blockchain Ethereum. Por meio da Web3j o módulo cliente se conecta por meio do protocolo HTTP ou IPC a qualquer fonte de dados compatível com a RPC Blockchain, incluindo nós locais conectados à rede principal ou a redes de teste (testnets) Ethereum, programas que emulam a execução de uma Blockchain ou a serviços Web compatíveis.
A biblioteca também possui funcionalidade para gerar classes geradas dinamicamente baseadas no código de Smart Contracts, facilitando a integração do Ethereum com projetos Java.

{\color{ForestGreen}Figura dos principais componentes em alto nível: programa cliente (exemplo celular ou notebook), servidor de armazenamento de arquivos; blockchain ethereum; contratos inteligentes; servidor de chaves de permissões.}

\begin{figure}[H]
  \centering
  \includesvg[width=1.1\linewidth]{images/diagrama-SmartDCPABE.svg}
  {Funcionamento geral e interação entre os módulos cliente, servidor de armazenamento de arquivos e Smart Contracts na Blockchain Ethereum.}
  \label{fig:diagramaSmartDCPABE}
\end{figure}

{\color{ForestGreen}Explicar um cenário de uso passo-a-passo (exemplo, milestone 1, mas com permissões direcionadas ao contexto de saúde, por exemplo um paciente quer dar permissão de acesso a médicos cardiologistas) (2 parágrafos)}.

A Figura \ref{fig:diagramaSmartDCPABE} apresenta os componentes do sistema e seu funcionamento.
(1) Uma autoridade usa o módulo cliente gera chaves privadas, públicas e pessoais de atributos;
(2) A autoridade usa o módulo cliente para aplicar as políticas de acesso em prontuários eletrônicos de pacientes (PEP), tarefa que pode ser automatizada no caso de uma migração de bases de dados para o sistema proposto;
(3) o módulo cliente aciona um Smart Contract que reúne informações públicas sobre atributos recebe as novas chaves e as disponibiliza para consulta;
(4) durante o envio de um arquivo ao servidor, o módulo cliente aciona um Smart Contract de gestão de arquivos cifrados e cadastra os metadados referentes ao arquivo, entre eles o servidor de hospedagem e o código de acesso;
(5) o cliente envia ao servidor os dados criptografados para armazenamento e consulta;
(6) um usuário pode consultar metadados sobre um arquivo e as chaves existentes de atributos e pode requisitar ao servidor o arquivo, descriptografá-lo e editá-lo localmente conforme a necessidade.
Havendo alteração no documento, o usuário aciona o módulo cliente para realizar a criptografia, envia os novos dados ao servidor e atualiza o registro do arquivo no Smart Contract no caso onde a política de acesso foi alterada.
A linha tracejada indica uma conexão estabelecida fora do sistema entre a autoridade e usuário para a entrega de uma chave pessoal de um atributo, usando qualquer meio de transmissão de dados que as partes considerem seguro.

Em um contexto específico da saúde, o sistema funcionaria da seguinte forma:
Uma paciente de nome Alice receberia um documento digital, por exemplo um encaminhamento médico para outra especialidade, e deseja juntar a documentação ao seu PEP.
Ela utiliza um programa específico para editar seu prontuário, adicionando este documento digital à estrutura de dados do prontuário e utiliza o módulo cliente para criptografar o documento usando um esquema criptográfico ABE, cifrando o documento de acordo com uma política de acesso que ela tenha escolhido ou concordado em usar.
Para este caso de uso, suponhamos que a tal política seja a seguinte:

\[paciente \vee (Hospital\ X \wedge Hematologista)\]

Essa política garante acesso ao próprio paciente e aos médicos da especialidade Hematologista e vinculados ao Hospital X, e pode ser descrita trocando os símbolos dos operadores lógicos pelo seus nomes em inglês, ou seja, ``paciente OR (Hospital-X AND Hematologista)''.
Repare que a aplicação da política é realizada pelo próprio usuário, efetivamente entregando o controle da segurança da informação ao paciente e respeitando seu direito à privacidade e à informação médica.

Ao cifrar o documento, ele está pronto para ser enviado.
Sob o comando do usuário o cliente solicita a reserva de um código de acesso de arquivos a um servidor, caso seja o primeiro envio deste documento, realiza o envio à Blockchain informando diversos dados: o código de acesso, a identificação do servidor, o nome do arquivo, a política de acesso, o instante em que a transação está sendo feita e extratos de dados produzidos pela criptografia ABE necessários para decifrar o arquivo.
Caso não seja o primeiro envio do arquivo\footnote{Os arquivos são considerados os mesmos se tiverem o mesmo nome.}, o cliente só enviará a nova versão ao servidor e só alterará a Blockchain quando houver necessidade de atualizar algum dos dados que tenham sofrido alteração.

Em um segundo momento Bob, o Hematologista do Hospital X, ciente do agendamento da consulta de Alice e em posse de uma ficha cadastral dela onde conste a carteira Ethereum cadastrada no sistema, usa o cliente para consultar na Blockchain informações de seu prontuário médico.
Ao baixar os metadados do arquivos, ele requisita o documento cifrado ao servidor de arquivos e decifra o documento utilizando o extrato do processo de criptografia e suas chaves pessoais dos atributos referidos na política de acesso, decifrando com sucesso o arquivo e usando um programa específico para visualizar e editar o prontuário.

\subsection{Taxonomia de permissões}
\label{sec:sub:taxonomia-permissoes}

{\color{ForestGreen}Explicar que o servidor de permissões deverá ser responsabilidade de uma organização apta para entregar as permissões online (ex. Ministério de Saúde ou algúm conselho federal/regional de medicina) (1 parágrafo)}.

A gestão de acesso a arquivos no sistema é feita pelos usuários, configurando grupos de acesso combinando os operadores lógicos e atributos que representam credenciais de acesso por quem as possui.
É denominado como autoridade ou certificador quem cria atributos, publica na Blockchain e processa as requisições de concessão deste atributo registradas na Blockchain.
Qualquer usuário pode se tornar um certificador, bastando publicar um atributo na Blockchain para que sejam registrados como tais em uma lista pública de certificadores mantida pelo contrato \emph{SmartDCPABEAuthority}.
Entidades como o Ministério da Saúde, os Conselhos Federais e Regionais de Medicina, e todos os laboratórios, clínicas e hospitais se tornariam certificadores, passando a publicar atributos que seriam úteis para a escrita de política de acesso em um prontuário médico.
A identidade principal do certificador é seu endereço de carteira ao invés de seu nome, acrescentada ao sistema somente para facilitar a operação e prover um sistema de identificação básico na Blockchain sem a necessidade de terceiros.

{\color{RoyalBlue} Professor, inicialmente comecei a descrever a forma com que uma autoridade se cadastrava no sistema, mas acabei entrando em detalhes técnicos. Estou pensando em mover isso para a seção \ref{sec:sub:ImplementacaoSmartContracts} na parte onde se fala do contrato \emph{SmartDCPABEAuthority} }

Usar endereços de carteira Ethereum como a identidade principal de certificadores impossibilita um agente mal intencionado a forjar a identidade de um certificador já cadastrado, uma vez que para se passar por ele o atacante teria que derivar a chave privada a partir do endereço da carteira, o que não pode ser feito.
Ainda resta o cenário onde um atacante se cadastra no sistema antes mesmo do certificador e usufrui desta posição até ser descoberto, lançando atributos que serviriam como backdoor nas políticas de acesso definidas pelo usuário, podendo acessar arquivos onde seus atributos fossem condição suficiente para a descriptografia.
Isso também poderia ser evitado ao assumir um esquema de consumo de tokens no ato do registro de uma autoridade no sistema, como por exemplo o hashing do nome da instituição e um endereço de carteira informado previamente ao responsável pela implantação do sistema.
A verificação da validade de uma solicitação de cadastro de uma autoridade seria simplesmente calcular o hashing da carteira e seu nome e verificar com essa lista de hashes disponíveis ao contrato.
Por não exporem informação sensível, esses hashes poderiam ser uma estrutura de dados no contrato que gerencia as autoridades ou constituir um contrato auxiliar próprio, que seria atualizado pelos administradores da implantação e utilizado pelo contrato principal.

{\color{ForestGreen}Explicar que a autenticação de uma pessoa para obter a permissão deverá ser realizada de forma externa ao sistema proposto (1 parágrafo).}

Atributos são gerados a partir de requisições feitas por usuários e publicadas na blockchain, por meio de um Smart Contract específico para armazená-las e atualizar o seu estado.
É necessário que o usuário tenha previamente se registrado em um contrato específico para gestão de usuários para poder requisitar a concessão de um atributo, informando a carteira e dados básicos de identificação.
Após a autoridade gerar uma chave pessoal de atributo, este é encaminhado de forma externa ao sistema, eliminando desta forma a existência de outros algoritmos e chaves que não fossem relacionados ao trabalho.
Teoricamente seria possível criar um canal seguro entre usuários sem a adição de outros algoritmos e chaves distintas das já utilizadas uma vez que o Ethereum cria um par de chaves que poderiam ser usadas como chaves assimétricas em um sistema de criptografia de curva-elíptica \emph{(Elliptic-Curve Cryptography - ECC)}, porém tal investigação está além do escopo deste trabalho\footnote{O par de chaves pública e privada geradas pelo Ethereum pertence à curva secp256k1, que não é considerada segura.
Estudar um sistema com essa capacidade envolveria em primeiro lugar a escolha de uma blockchain alternativa compatível com as curvas consideradas seguradas para realizar a ECC \cite{Bernstein2017}.}.
Desta forma, uma vez geradas as chaves, fica a critério do certificador escolher o método de envio das chaves, utilizando uma infraestrutura de TI própria, serviços de terceiros ou mesmo a cópia em mídia física.

{\color{ForestGreen}Explicar que foi realizada uma taxonomia das possíveis permissões que seriam utilizadas no sistema para o contexto médico. (3 parágrafos explicando como foi realizado o levantamento, me lembro que tinha um artigo e uma lista gigante que foi filtrada por quantidade de médicos).}

O sistema proposto pretende integrar diversas bases de dados de diferentes órgãos que, quando tornados  certificadores, serão providos com a capacidade de publicar tantos atributos quanto considerarem necessários.
A autonomia dos agentes para criar atributos pode se tornar um risco à gestão do sistema, evidenciando a necessidade de coordenação entre na publicação de atributos para que as  políticas de acesso se demonstrem harmônicas, funcionais e previsíveis ao longo do tempo, podendo ser acessadas e compreendidas por entidades distintas.
Sem uma proposta de padronização, corre-se o risco das entidades desenvolverem padrões distintos e provavelmente conflitantes no que diz respeito ao escopo, uso e descrição textual de um atributo.

A diferença de hierarquia das instituições na área da saúde, em suas competências e especialidades,  suas políticas de acesso à informação e suas normas internas certamente resultariam em diversas configurações distintas e incompatíveis dos atributos em um esquema criptográfico ABE.
Um sistema que pretenda permitir o acesso a prontuários médicos distribuídos entre instituições com este esquema deve, portanto, propor também uma norma para a criação e gestão de atributos e de escrita das políticas de acesso.
Para atingir este fim, buscou-se o denominador comum entre as exigências e restrições a que devem ser submetidos todos os operadores na área da saúde, modelando-se uma taxonomia de acordo com os papéis envolvidos na gestão e uso dos dados médicos de paciente, partindo da análise das normas que regem o trabalho do profissional da saúde.

O Código de Ética Médica (CEM) trata da conduta médica em diversos casos e entre elas institui regras de conduta para o acesso e gestão de informações médicas, provendo os elementos necessários para a elaboração de uma taxonomia de condição de acesso a um prontuário médico, conforme mostra a figura \ref{fig:taxonomiaPermissoes}.
Isso já permite descrever qual será a política elementar e universal ao qual qualquer prontuário médico deve se submeter:

\[ CFM \vee CRM \vee Paciente \vee Terceiro\textnormal{-}Autorizado \]

Essa política padrão se refere à criptografia que será aplicada à estrutura mais externa do PEP, e só descreve as condições mínimas de acesso que deverão constar nesta fórmula por possuírem acesso irrestrito segundo a CEM, podendo-se adicionar mais cenários de acesso.
Pode ainda considerar a estrutura do prontuário eletrônico como uma árvore de dados compatível com XML.
Além da norma nacional \cite{SociedadeBrasileiradeInformaticaemSaude2016} e normas internacionais ISO/EN 13.606 e HL7 previrem essa estrutura \cite{Munoz2011, Dolin2000}, projetos de especificação aberta como a iniciativa OpenEHR \cite{openEHRFoundation2020} e as próprias ferramentas e padrões de serviço Web contemporâneos favorecem a adoção de estruturas de dados XML (ou compatíveis, como o JSON) como veículo de representação, transmissão e exportação de dados.
Uma estrutura em árvore possibilita a aplicação de criptografia a seus subelementos, oferecendo assim o controle personalizado pelo paciente da granularidade das políticas de acesso sobre seus dados por terceiros.
Caso exista uma política de acesso em alguma subseção do prontuário, será obrigatório conceder o acesso ao menos aos Conselhos de Medicina Federal e Regional.
Outras regras podem ser abstraídas a partir da taxonomia, como por exemplo a substituição dos elementos $Paciente$ em caso de prontuários de menor de idade, uma vez que este não deveria ter a autonomia sobre a gestão dos próprios dados, produzindo a seguinte política de acesso:

\[ CFM \vee CRM \vee Respons\acute{a}vel\textnormal{-}Legal \vee Terceiro\textnormal{-}Autorizado \]

A taxonomia consegue estipular os diferentes papéis de acesso a um prontuário, mas ainda é necessário adequar e categorizar as diversas funções na área da saúde que precisarão, eventualmente, ter acesso a prontuários médicos.
A estratégia para propor uma categorização abrangente e relevante envolveu obter dados do DATASUS (Órgão que administra a consulta de informações do Sistema de Saúde Pública) sobre todas as profissões registradas na área da Saúde relativas ao início do ano de 2019 no Brasil.
Na pesquisa obteve-se mais de 400 profissões distintas, que foram agregadas pelo nível de ensino e pela área de atuação.
Isso resultou em uma segunda taxonomia, disponível no Anexo \ref{etc:anexoI}, que serve como referência para a criação de atributos específicos para profissionais com escopos comuns entre os certificadores.

A entidade responsável por emitir o atributo a um médico seria o CRM de sua região.
As demais entidades emitiriam os atributos que descrevem outros grupos de profissionais que necessitam acessar os dados do paciente, tais como setor administrativo ou o corpo de funcionários técnico-hospitalar.
Os usuários também geram alguns atributos pré-definidos, porém diferente dos certificadores, estes não são publicados na Blockchain.
A função destes atributos criados pelo usuário é conceder o acesso dele mesmo e de terceiros ao prontuário, por meio dos atributos $Paciente$ e $Terceiro\textnormal{-}Autorizado$.
O atributo $Respons\acute{a}vel\textnormal{-}Legal$ seria um atributo gerado por um usuário para cifrar o prontuário de um outro usuário que não seja juridicamente responsável por si mesmo.

{\color{ForestGreen}Figura da taxonomia}.

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{images/taxonomia-de-permissoes.png}
  \caption{Taxonomia de permissões de acesso a prontuários segundo a norma do Código de Ética Médica}
  \label{fig:taxonomiaPermissoes}
\end{figure}

{\color{ForestGreen}Explicar que no sistema proposto existe um servidor de atributos ao qual se pedem as chaves públicas/privadas para realizar a encriptação/decriptação (1 parágrafo).}

Do ponto de vista computacional, atributos são pares chaves privada e pública, sendo a chave privada usada para derivar um conjunto de chaves pessoais que são concedidas aos usuários. As chaves públicas são utilizadas para criptografar e as chaves pessoais são utilizadas para descriptografar um conteúdo.
Um atributo precisa ser publicado na blockchain para ser utilizado pelos outros usuários, e considera-se publicado o atributo que tenha seus parâmetros de chave pública enviados ao contrato SmartDCPABEKeys, que as disponibiliza para consulta.
De posse da chave pública é possível criptografar um arquivo com uma política de acesso descrita em termos daqueles atributos e, caso o usuário possua as respectivas chaves privadas pessoais também, é possível descriptografar o conteúdo cifrado.
As operações criptográficas sempre ocorrem localmente para evitar a exposição de informação sensível à rede a qual está conectado.

{\color{ForestGreen}Explicar como é realizado o passo-a-passo para o pedido/entrega das chaves (note que aqui a descrição é muito mais profunda que o que foi mencionado na visão geral) (1 parágrafo).}

O conjunto de chaves privadas pessoais deriva de uma chave privada secreta associada a um atributo público e de posse do certificador que a gerou.
Para assegurar a unicidade da chave privada, também é necessário derivar a chave a partir de um identificador único (ID) associado ao usuário.
Utilizar chaves privadas de atributos com ID distintos entre si causa uma falha na descriptografia, assegurando que atributos não sejam intercambiáveis entre os usuários.

O mecanismo de derivação de chaves privadas pessoais implementado no cliente está atrelado ao processamento de requisições, impedindo o certificador de conceder chaves arbitrariamente sem uma requisição prévia.
Isso é uma estratégia para limitar o poder do certificador em criar atributos e dessa forma abusar de sua autoridade para conceder acesso indevido a agentes não autorizados e possivelmente levar a um acesso não autorizado de dados.
O certificador portanto consulta a blockchain para obter novas requisições e decide se irá processá-la ou não.
Nos dois casos, a resposta retorna à blockchain assim que a chave é criada ou quando sua criação é negada, quer seja por decisão do certificação ou por falha devido a parâmetros incorretos, e o requerente do atributo fica ciente que sua requisição foi consumida, devendo realizar uma nova caso necessário.

\subsection{Contratos inteligentes com CBA}
\label{sec:sub:ImplementacaoSmartContracts}

Foram desenvolvidos cinco contratos inteligentes que permitem a autenticação, entrega de permissões e armazenamento de metadados dos prontuários eletrônicos dos pacientes.
A seguir serão explicados cada um deles.

{\color{ForestGreen} Explicação do  SmartDCPABEAuthority (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados.}

{\color{Magenta} 1 parágrafo para explicar o que faz o contrato (em linhas gerais).}

O contrato \emph{SmartDCPABEAuthority} registra na Blockchain as entidades certificadoras disponíveis no sistema, tornando público seu endereço público na Ethereum, associando dados de identificação e a quantidade de atributos que a entidade já publicou.
o ID usado para derivar as chaves privadas dos atributos no esquema ABE é a chave privada que corresponde à chave pública do Ethereum.
Esse esquema permite que uma entidade possa ser identificável de forma única sem a necessidade de controle centralizada sobre o cadastro de novas unidades.
A escolha do ID visa impossibilitar um atacante de se passar pela entidade certificadora, uma vez que não há método computacionalmente viável para recuperar a chave privada de um endereço Ethereum a partir de uma chave pública.

{\color{Magenta} Inserir o código da linha 7 até 20.}

\lstset{basicstyle=\small, numbers=left, language=bash, keywordstyle=\color{blue}, numbersep=1pt, label={cod:SmartDCPABEAuthority}, caption={Dados em SmartDCPABEAuthority}}
\begin{lstlisting}
 contract SmartDCPABEAuthority is Collection {

 struct Certifier {
   address addr;
   bytes32 name;
   bytes32 email;
   uint64 numPublicKeys;
 }

 address[] public certifierAddresses;
 mapping (address => Certifier) certifiers;
\end{lstlisting}

{\color{Magenta} 1 parágrafo para explicar para que serve CADA UM dos structs, events e atributos. Exemplo. O struct X permite armazenar dados que servirão para Y. O atributo V armazena informações de W que servirão para Z.}

A sessão de código \ref{cod:SmartDCPABEAuthority} exibe a estrutura básica do contrato.
A struct Certifier armazena dados informações da autoridade responsável por publicar atributos e concedê-los a usuários.
Além do endereço Ethereum, também é armazenado seu nome, e-mail e a quantidade de chaves que ele já publicou.
Tal unidade de controle é necessária porque as chaves são armazenadas em \emph{mappings}, conforme explicitado na Sessão \ref{sec:sub:contratos-ethereum}.

{\color{ForestGreen} Explicação do  SmartDCPABEKeys (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados.}

{\color{Magenta} 1 parágrafo para explicar o que faz o contrato (em linhas gerais).}

O contrato \emph{SmartDCPABEKeys} (código \ref{cod:SmartDCPABEKeys}) disponibiliza a chave pública de atributos criados por autoridades.
Para fins de prototipagem foram implementadas somente as operação de inclusão e consulta de chaves, mas não de edição ou remoção.
Seria trivial implementar isto no Smart Contract, mas não seria trivial e nem viável implementar os protocolos de revogação e substituição de atributos no módulo Cliente, responsável pelas operações criptográficas e pela coordenação das informações entre a Blockchain e o Servidor.

{\color{Magenta} Inserir o código da linha 6 até 24.}

\lstset{basicstyle=\small, numbers=left, language=bash, keywordstyle=\color{blue}, numbersep=1pt, label={cod:SmartDCPABEKeys}, caption={Dados em SmartDCPABEKeys}}
\begin{lstlisting}
 contract SmartDCPABEKeys is Collection {

 struct PublicKey {
  Bytes127 eg1g1ai;
  Bytes127 g1yi;
 }

 struct Bytes127 {
  bytes32 chunk1;
  bytes32 chunk2;
  bytes32 chunk3;
  bytes31 chunk4;
  uint8 lastChunkSize;
 }

 mapping (address => bytes32[]) publicKeyNames;
 mapping (address => mapping (bytes32 => PublicKey)) ABEKeys;
\end{lstlisting}

{\color{Magenta} 1 parágrafo para explicar para que serve CADA UM dos structs, events e atributos.}

a estrutura \emph{Bytes127} foi criada como um container econômico para armazenar os elementos gerados pela biblioteca jPBC \emph{(Java Pairing-Based Cryptography)} \cite{DeCaro2011}.
O tamanho dos elementos varia entre 120 a 124 bytes de informação e, embora o Solidity disponha da estrutura de dados \emph{bytes} para armazenar bytes em tamanho arbitrário, seu custo é maior.
Dados consomem gas, e quando são utilizadas estruturas de dados de tamanho dinâmico, o valor é maior do que suas contrapartes estáticas, justificando a criação de uma estrutura que divida os dados em um conjunto de elementos de tamanho fixo.
A estrutura \emph{PublicKey} armazena a chave pública gerada pela biblioteca \emph{DCPABE}\footnote{código fonte: \href{https://github.com/stefano81/dcpabe}{\texttt{https://github.com/stefano81/dcpabe}}. Para uma análise teórica, ver \cite{Lewko2011}}, que são representadas por duas sequências de bytes como mostra o código.
O mapa \emph{publicKeyNames} mapeia um endereço de uma autoridade a uma lista de nomes de atributos representados como bytes.
O mapa \emph{ABEKeys} contém, para cada endereço cadastrado, um submapa relacionando o nome do atributo representado em bytes com uma chave pública.

{\color{ForestGreen} Explicação do  SmartDCPABEFiles  (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados.}

{\color{Magenta} 1 parágrafo para explicar o que faz o contrato (em linhas gerais).}

O contrato \emph{SmartDCPABEFiles} (código \ref{cod:SmartDCPABEFiles}) mantém disponível na blockchain informações sobre a hospedagem do arquivo de prontuários e também os dados do objeto \emph{Ciphertext} produzido pela Biblioteca DCPABE, necessário para realizar a descriptografia. O contrato também gerencia informações sobre as bases de dados onde os arquivos estão hospedados.

{\color{Magenta} Inserir o código da linha 6 até 39.}

\lstset{basicstyle=\small, numbers=left, language=bash, keywordstyle=\color{blue}, numbersep=1pt, label={cod:SmartDCPABEFiles}, caption={Dados em SmartDCPABEFiles}}
\begin{lstlisting}
 contract SmartDCPABEFiles is Collection {

 struct Recording {
  uint64 serverID;
  bytes32 key;
  bytes32 hashing;
  uint64 timestamp;
 }

 struct Ciphertext {
  string policy;
  bytes c0;
  bytes c1;
  bytes c2;
  bytes c3;
 }

 struct FileServer {
  bytes32 domain;
  bytes32 path;
  uint16 port;
 }

 uint64 public numServers;
 mapping (address => string[]) fileNames;
 mapping (address => mapping(string => Recording)) files;
 mapping (address => mapping(string => Ciphertext)) ciphertexts;

 FileServer[] servers;
\end{lstlisting}

{\color{Magenta} 1 parágrafo para explicar para que serve CADA UM dos structs, events e atributos.}

A Estrutura \emph{Recording} informa a base de dados na qual o arquivo está hospedado e qual é a sua identificação no servidor, o hashing para permitir a verificação de integridade e uma marca temporal para manter registro público do momento de sua publicação na Blockchain. Seria possível remover o campo timestamp e trabalhar somente com altura ou timestamp do bloco em que a transação foi validada, economizando o uso de gas, porém deixando de possuir uma data exata de publicação de um documento. A estrutura \emph{Ciphertext} contém a política de acesso utilizada para cifrar o arquivo e um conjunto de parâmetros (c0 a c3) que resultam do processo de criptografia e que são necessários para decifrar o documento. A estrutura \emph{FileServer} contém informações para conexão com uma base de dados na Internet. O contrato mantém uma lista de servidores \emph{servers} e um par de mapas \emph{files} e \emph{ciphertexts} com estrutura similar, ligando endereços de usuários a submapas que associam, por sua vez, um nome de arquivo às estruturas de dados \emph{Recording} e \emph{Ciphetext} relacionadas àquele arquivo. Disso segue-se que uma edição no conteúdo é mais barato que a alteração no nome do documento, uma vez que no caso do conteúdo somente o hashing e o timestamp são atualizados, enquanto que na renomeação o mapa armazena o arquivo como se fosse um novo, sendo necessário publicar os dados do arquivo e deletar aqueles que estavam disponibilizados.

{\color{ForestGreen} Explicação do  SmartDCPABERequests  (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados.}

{\color{Magenta} 1 parágrafo para explicar o que faz o contrato (em linhas gerais).}

O contrato \emph{SmartDCPABERequests} (código \ref{cod:SmartDCPABERequests}) é responsável por lidar com requisições de concessão de atributos.
Usuários do sistema publicam suas requisições e as autoridades certificadoras podem checar por requisições pendentes e atendê-las ou rejeitá-las.
Uma requisição pode solicitar a concessão de um ou mais atributos a um mesmo certificador e é consumida quando processada, não sendo possível alterar novamente seu status.
A transmissão dos atributos ocorre fora da blockchain e pode usar qualquer meio de comunicação considerado seguro entre as partes.

{\color{Magenta} Inserir o código da linha 6 até 35.}

\lstset{basicstyle=\small, numbers=left, language=bash, keywordstyle=\color{blue}, numbersep=1pt, label={cod:SmartDCPABERequests}, caption={Dados em SmartDCPABERequests}}
\begin{lstlisting}
 contract SmartDCPABERequests is Collection {

 enum KeyRequestStatus {
  PENDING,
  OK,
  REJECTED
 }

 struct KeyRequest {
  KeyRequestStatus status;
  uint64 timestamp;
  uint64 responseTimestamp;
  bytes32[] attrNames;
 }

 event pendingRequestIndexChanged(uint64 oldIndex, uint64 newIndex);
 event pendingRequesterIndexChanged(uint64 oldIndex, uint64 newIndex);

 mapping (address => address[]) pendingRequesters;
 mapping (address => mapping (address => uint64[]))  pendingRequests;
 mapping (address => mapping (address => KeyRequest[]))  requests;
\end{lstlisting}

{\color{Magenta} 1 parágrafo para explicar para que serve CADA UM dos structs, events e atributos.}

A estrutura \emph{KeyRequest} representa uma requisição de atributos, contendo um campo para indicar a situação, marcas temporais da criação e processamento da requisição e uma lista de nomes de atributos representados como sequências de 32 bytes (Bytes32).
As situações estão listadas no enum \emph{KeyRequestStatus}, e podem ser expandidas para um conjunto maior de situações, conforme a necessidade das entidades que utilizem um sistema assim.
Dois eventos notificam sobre o processamento de requisições, para que os interessados possam atualizar seu cache local com a blockchain e obter assim o estado mais atualizado das requisições.
O mapa \emph{requests} usa endereços de certificadores como chave primária para submapas cujas chaves são os endereços de usuários e que levam às listas de requisições feitas por eles.
O mapa \emph{pendingRequests} segue esta mesma estrutura, com a diferença de apenas armazenar os índices das listas de requisições em \emph{requests} que estão pendentes de processamento.
O mapa \emph{pendingRequesters} mantém os endereços de usuários com requisições pendentes em listas agregadas por certificador, possibilitando que estes possam iterar pelo mapa \emph{pendingRequests}, obtendo os índices de acesso das requisições de interesse gravadas em \emph{requests}.

{\color{ForestGreen} Explicação do  SmartDCPABEUsers  (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados.}

{\color{Magenta} 1 parágrafo para explicar o que faz o contrato (em linhas gerais).}

O contrato \emph{SmartDCPABEUsers} (código \ref{cod:SmartDCPABEUsers}) gerencia o cadastro de usuários passíveis de obter atributos no esquema de criptografia ABE e exercer papeis dentro do deste sistema, implementando funções básicas de inclusão, consulta e checagem de usuários válidos.
A estrutura \emph{User} atrela dados básicos de identificação a um endereço válido de carteira Ethereum, e instâncias desta estrutura são salvas em um mapa \emph{users}, onde a chave deste mapa é o próprio endereço do usuário.
A lista \emph{userAddresses} armazena todos os endereços já cadastrados para permitir a iteração, se necessária, sobre as chaves do mapa \emph{users}.

{\color{Magenta} Inserir o código da linha 6 até 16.}

\lstset{basicstyle=\small, numbers=left, language=bash, keywordstyle=\color{blue}, numbersep=1pt, label={cod:SmartDCPABEUsers}, caption={Dados em SmartDCPABEUsers}}
\begin{lstlisting}
 contract SmartDCPABEUsers is Collection {

 struct User {
  address addr;
  bytes32 name;
  bytes32 email;
 }

 address[] public userAddresses;
 mapping (address => User) users;
 uint64 public numUsers;
\end{lstlisting}

{\color{Magenta} 1 parágrafo para explicar para que serve CADA UM dos structs, events e atributos.}

{\color{RoyalBlue} esse parágrafo foi agregado ao anterior porque os dois são pequenos, afinal o código deste contrato é pequeno.}

\subsection{Arquitetura Blockchain}

Como mencionado na Seção \ref{sec:sub:visaogeral}, o sistema é composto por 3 componentes: cliente, servidor, e a Blockchain. A Figura X mostra o relacionamento entre esses componentes.

{\color{ForestGreen} Fazer uma figura simples que mostre os 3 componentes interligados. }


{\color{ForestGreen} Explicar implementação do cliente (5 parágrafos). Ver abaixo os 5 parágrafos destrinchados. }

{\color{Magenta} 1 parágrafo para explicar que para realizar a conexão com a Blockchain usou o web3j (explique em 2-3 linhas o web3j).}

A Web3j fornece conectividade com diferentes fontes de dados para consulta do estado de transações e envio de novas transações em blockchains compatíveis com o protocolo JSON-RPC Ethereum\footnote{ver \href{https://github.com/ethereum/wiki/wiki/JSON-RPC}{https://github.com/ethereum/wiki/wiki/JSON-RPC}.}, compreendendo a rede principal (\emph{MainNet}), as redes de teste oficiais Ropsten, Rinkeby e Kovan, redes permissionadas usando o Hyperledger Besu ou simulações da rede Ethereum para teste por meio de programas como o Ganache.
A Web3j se conecta ao provedor de dados por meio de Protocolos HTTP/HTTPS e IPC.

\lstset{basicstyle=\small, numbers=left, language=java, keywordstyle=\color{blue}, numbersep=1pt, label={cod:conexãoBlockchain}, caption={Código para conexão com a Blockchain usando o web3j}}

\begin{lstlisting}
 private final Web3j web3j;

 public BlockchainConnection(String networkURL, ...) {
   // codigo omitido por brevidade
   web3j = Web3j.build(new HttpService(networkURL));
 }
\end{lstlisting}

{\color{Magenta} 1 parágrafo para explicar as 3 linhas mais importantes do código fonte de como realizar a conexão. Explicar cada linha do código. }

Dentro do módulo Cliente, a classe \emph{BlockchainConnection} é a responsável por lidar com a Blockchain por meio do Web3j e as classes em Java que representam os Smart Contracts, e exige somente um endereço de rede válido para uma porta no computador ou rede local onde exista comunicação com um programa compatível com a API JSON-RPC do Ethereum, ou para um serviço Web na internet que ofereça a API, tais como os sites Infura e Ethercluster.
O endereço informado é armazenado no cache do programa para uso em execuções futuras.

{\color{Magenta} 1 parágrafo para explicar que para encriptar um documento utilizando atributos usou a dcpabe.}

A biblioteca DCPABE desenvolvida em Java possui suporte à operações criptográficas do protocolo ABE em um ambiente com múltiplas autoridades, conforme descrito em \cite{Lewko2011}.
Ela depende por sua vez da biblioteca \emph{jPBC} (Java Pairing Based Cryptography), a primeira e mais abrangente biblioteca de código aberto para criptografia baseada em emparelhamento em Java e compatível com Android, tendo o objetivo explícito de portar a biblioteca PGC\footnote{mais informações em \href{https://crypto.stanford.edu/pbc/}{https://crypto.stanford.edu/pbc/}}, originalmente escrita em C, para código nativo em Java e oferecer uma interface para essa biblioteca \cite{DeCaro2011}.
A DCPABE fornece todo o ferramentário necessário para o uso do esquema ABE, incluindo a geração de parâmetros globais, geração de chaves privadas, públicas e pessoais dos atributos, cifra e deciframento de fluxos de dados.
Ao criptografar um documento, um objeto do tipo \emph{Ciphertext} contendo os parâmetros necessários para a decifragem é serializado e escrito no início do arquivo container dos bytes criptografados.
Esse comportamento foi alterado para produzir um artefato equivalente, serializável em JSON, escrito em um arquivo separado daquele que contem os bytes criptografados, com a finalidade de poder publicar na Blockchain somente este artefato JSON, ao invés de todo o arquivo, e assim reduzir os custos de transação e viabilizar o uso da rede Ethereum.

{\color{Magenta} 1 parágrafo para explicar as 3 linhas mais importantes do código fonte de como realizar a encriptação. Explicar cada linha do código.}

\lstset{basicstyle=\small, numbers=left, language=java, keywordstyle=\color{blue}, numbersep=1pt, label={cod:métodoCriptografia}, caption={Criptografando um arquivo usando a biblioteca DCPABE}}

\begin{lstlisting}
 public void encrypt(String file, String policy, String[] authorities) {
   // codigo omitido por brevidade
   AccessStructure as = AccessStructure.buildFromPolicy(policy);
   Message m = DCPABE.generateRandomMessage(gp);
   CiphertextJSON ct = new CiphertextJSON(DCPABE.encrypt(m, as, gp, pks));
   r = new Recording(path, file, ct);
   r.encryptFile(m);
 }
\end{lstlisting}

% O objeto \emph{as}, instância da classe \emph{AccessStructure}, armazena uma representação matricial da fórmula boooleana descrita em \emph{policy}, produzindo uma estrutura de acesso de um \emph{LSSS} (Linear Secret Sharing Scheme), tornando a fórmula um elemento matricial vetorial compatível com a estrutura matemática necessária ao funcionamento dos algoritmos definidos pelo DCPABE.

A classe \emph{Client} implementa a função \emph{encrypt}, em parte exposto seção de código \ref{cod:métodoCriptografia}.
A função encrypt exige os parâmetros \emph{file} contendo o nome do arquivo a ser criptografado, \emph{policy} contendo uma política de acesso e o vetor \emph{authorities} contendo o ID das autoridades dos atributos relacionados em \emph{policy}.
Na linha 3 o objeto \emph{as}, instância da classe \emph{AccessStructure}, armazena uma representação matricial gerada a partir da fórmula boooleana descrita em \emph{policy}, tornando a fórmula em um elemento matricial vetorial compatível com a estrutura matemática necessária ao funcionamento dos algoritmos definidos pelo DCPABE.
Na linha 4 é definido como mensagem \emph{m} um elemento aleatório pertencente ao grupo do aparelhamento definido pelos parâmetros globais \emph{gp} -- o mesmo utilizado para a geração de chaves privas dos atributos.

Na linha 5 a mensagem m é ocultada sob a criptografia ABE utilizando a matriz \emph{as}, a mensagem \emph{m}, os parâmetros globais \emph{gp} e um vetor \emph{pks} com as chaves públicas de todos os atributos mencionados em \emph{policy}, retornando uma instância equivalente à da classe \emph{Ciphertext}, com a capacidade de ser serializada em JSON, e na linha 7 o arquivo é cifrado usando um algoritmo AES\footnote{Especificamente, é usada a classe AESEngine da biblioteca Bouncy Castle com configuração padrão. Ver \href{https://people.eecs.berkeley.edu/~jonah/bc/org/bouncycastle/crypto/engines/AESEngine.html}{https://people.eecs.berkeley.edu/~jonah/bc/org/bouncycastle/crypto/engines/AESEngine.html}} e a mensagem \emph{m} como chave. A descriptografia consiste em fornecer as chaves pessoais dos mesmos atributos usados na criptografia, aplicando o esquema ABE para obter a mensagem \emph{m} e usando-a como chave do algoritmo AES para descriptografar o conteúdo desejado.

{\color{Magenta} 1 parágrafo para explicar as 3 linhas mais importantes do código fonte de como acessar um contrato inteligente. Explicar cada linha do código.}

\lstset{basicstyle=\small, numbers=left, language=java, keywordstyle=\color{blue}, numbersep=1pt, label={cod:acessoSmartContract}, caption={Acessando um Smart Contract na Blockchain}}

\begin{lstlisting}
 private CiphertextJSON getCiphertext(String user, String fileName) {
   Tuple5<String, byte[], byte[], byte[], byte[]> ciphertextData;
   try {
     ciphertextData = contractFiles.getCiphertext(user, fileName).send();
     if (!ciphertextData.getValue1().equals("")) {
       // codigo usando os dados retornados pelo contrato
     }
   } catch (Exception e) { ... }
 }
\end{lstlisting}

O Acesso aos Smart Contracts em Java é intermediado por classes "wrappers", isto é, classes geradas automaticamente a partir do EVM Code e da ABI \emph{(Application Binary Interface)} de Smart Contracts para interação com o contrato.
Estas classes contém métodos que correspondem às funções nos Smart Contract, possuindo dois métodos a mais, um para implantar o contrato na EVM e outro para carregar o contrato, caso já tenha sido implantado.
Uma vez inicializado, a interação ocorre como exemplifica a sessão de código \ref{cod:acessoSmartContract}.
Na linha 4 o método \emph{getCiphertext} do objeto \emph{contractFiles}, wrapper do contrato \emph{SmartDCPABEFiles}, recebe os argumentos necessários à função, prepara um objeto que representa uma chamada remota ao contrato, que é enviada à rede Ethereum por meio da invocação do método \emph{send()} ao fim da linha.

Funções de Smart Contracts podem retornar dados, e se for o caso, serão inseridos em um objeto do tipo \emph{TupleN}, sendo N o número de parâmetros retornados. Este objeto possui métodos na forma \emph{getValueN()} para acessar o n-ésimo valor de retorno do Smart Contract.
A checagem feita na linha 5 é necessária para identificar se o objeto retornado pelo Smart Contract é vazio.
Isto é necessário porque a implementação da EVM não possui um elemento nulo como na maioria das linguagens mais populares, e também não suspende a execução e retorna um erro quando tenta-se acessar uma chave inexistente de um mapa.
Quando a EVM encontra uma variável indefinida ou inexistente, seu comportamento padrão é retornar um valor do mesmo tipo da variável que corresponda ao valor FALSO de uma variável booleana.
Sem um mecanismo de erro ou identificação de valores nulos, torna-se necessário checar o valor de alguma das variáveis recebidas cujo valor não possa ser equivalente ao FALSO booleano.
No código \ref{cod:acessoSmartContract}, a variável escolhida é \emph{policy}, que ocupa a posição 1 da tupla e que nunca pode ser igual a uma string vazia, visto que isto significaria que o conteúdo não está criptografado, necessariamente significando que o valor de retorno se refere a valores nulos ou inexistentes.
Confirmado que os dados recebidos realmente existem, estes são processados conforme a necessidade, no escopo aninhado à verificação, na linha 6.

{\color{ForestGreen} Explicar implementação do servidor (3 parágrafos). Ver abaixo os 3 parágrafos destrinchados. }

{\color{Magenta} 1 parágrafo para explicar que o servidor utiliza REST para prover os serviços via web  (explique em 2-3 o que é REST).}

O módulo do servidor conta com uma estrutura padrão de acordo com os princípios REST, ou seja, oferece uma API acessível (via protocolo HTTP) com métodos GET, POST e PUT, atribui URIs a todos os recursos sob gestão do servidor e possui um modelo de comunicação \emph{stateless}, i.e., toda a informação necessária à interação deve estar contida na mensagem recebida pelo servidor, sem a necessidade dele controlar o estado de comunicação ou contexto da interação de cada um dos clientes \cite{Mark2013}.
O método DELETE não é implementado porque o sistema proposto é contextualizado e modelado para manter o registro permanecente e inviolável de dados de pacientes médicos, não havendo justificativa para a exclusão dos dados, uma vez que o sigilo é preservado e operações de atualização de dados são permitidas nos cenários onde for preciso atualizar ou corrigir os dados armazenados.
O módulo cliente utiliza a classe \emph{ServerConnection} para encapsular o acesso ao servidor, que foi executado localmente durante todas as fases de desenvolvimento e experimentação do protótipo.

{\color{Magenta} 1 parágrafo para explicar que o servidor possui o serviço para inserir um documento e para recuperar um documento.}

a API disponível permite o envio, substituição e recuperação de arquivos enviados ao servidor.
As URIs dos arquivos no servidor são construídas a partir de hashes SHA-256 gerados aleatoriamente, sendo gerados e enviados ao cliente como resposta de uma requisição sinalizando o envio de um novo arquivo para o servidor.
Sendo exigido para a publicação na Blockchain, o cliente precisa informar este hash que passa a ser tratado como uma chave de acesso para o arquivo no servidor, junto com a identificação do servidor e outros dados, conforme as estruturas de dados definidas no contrato SmartDCPABEFiles exigem (ver código \ref{cod:SmartDCPABEFiles}).
Usuários do sistema interessados no arquivo acessam seus metadados na Blockchain, entre eles a identificação do servidor e a chave que compõe a URI.
A partir daí o cliente pode montar a URL da requisição do arquivo e obtê-lo do servidor.

{\color{Magenta} 1 parágrafo para explicar que o servidor insere e recupera os prontuários eletrônicos de pacientes diretamente do seu sistema de arquivos advindos das requisições web.}

O servidor foi implementado para salvar os arquivos diretamente em seu sistema de arquivos local, sem criptografia adicional sobre o conteúdo uma vez que este já é enviado criptografado pelo cliente, restringindo acessos não autorizados por terceiros.
O fato do arquivo ser entregue sempre que requisitado a princípio não apresenta violações à privacidade e segurança dos dados, uma vez que está criptografado e só poderá ser decifrado por quem possua os atributos compatíveis com a política de acesso, porém é possível que um atacante escolha acumular arquivos sob sua posse e aguardar pela descoberta de vulnerabilidades críticas nas bibliotecas de criptografia que possibilitariam, no pior cenário possível, a quebra da criptografia. A fim de evitar isso, pode-se acrescentar desafios criptográficos que provem que o requisitante realmente possui os atributos necessários para decifrar o arquivo.

Pode-se recorrer a um esquema baseado no conceito da Prova de Conhecimento-Zero \emph{(Zero Knowledge-Proof - ZPK)}, onde um verificador (o servidor) pode ser "convencido" que um provador (o cliente) realmente possui um segredo, sem com isso ter de expor alguma informação que altere o nível de conhecimento prévio do verificador sobre aquele segredo \cite{Rice2010,Buchanan2017}.
Considere que o servidor deva se convencer da legitimidade da aquisição\footnote{interpretando uma aquisição legítima como aquela em que de fato o cliente possui a capacidade de descriptografar o conteúdo solicitado.} de um arquivo por um usuário, sem que o usuário tenha que revelar suas chaves ou sua identidade, evitando neste último caso o ônus ao servidor de verificar na Blockchain o histórico de concessões de atributos àquela identidade e testar a compatibilidade deles com a política de acesso do arquivo em questão, introduzindo estados intermediários e mutáveis entre requisições do cliente devido à consulta na Blockchain, que implicarão na quebra do princípio REST da comunicação sem estados.

Uma solução viável é exigir ao cliente que, no ato do envio de um arquivo para ser hospedado, calcule o hashing deste arquivo, cifre este valor com a mesma política de acesso usada para o arquivo e então envie este par de arquivos cifrados ao servidor.
O comportamento do servidor seria levemente modificado para que, diante de uma requisição de um arquivo sem parâmetros adicionais, a resposta seria o objeto cifrado que contém o valor do hashing enviado anteriormente pelo cliente.
Um usuário com as credenciais necessárias seria capaz de decifrar esse objeto, realizando novamente a requisição do mesmo arquivo, desta vez informando o hashing como parâmetro.
Diante de uma requisição de arquivo com algum parâmetro adicionado, o servidor verifica se seu valor é equivalente ao valor do hashing do arquivo sob sua posse.
Seria impraticável tentar acertar o valor do hashing ao acaso, de forma que caso sejam equivalentes, torna-se evidente que o usuário tem consigo os atributos necessários para decifrar o conteúdo do arquivo e o servidor envia o arquivo, negando o acesso nos casos contrários.

{\color{ForestGreen} Explicar implementação da Blockchain (4 parágrafos). Ver abaixo os 4 parágrafos destrinchados. }

{\color{Magenta} 1 parágrafo para explicar que a Blockchain utilizada foi a testnet (explicar que existe a main e a testnet, onde a testnet é utilizada por desenvolvedores serve para realizar implantações de teste sem dispender recursos financeiros.}

O desenvolvimento de aplicações para Ethereum exige em algum momento a interação com a rede.
O design de Smart Contracts e testes de integração exigem essa dinâmica, e pode-se querer ainda verificar o comportamento da aplicação após sua implantação, diante por exemplo do uso contínuo de uma base real de usuários ou da interação com outros projetos igualmente implantados na Blockchain.
Há todo um ecossistema em torno da rede Ethereum permitindo a simulação da rede em graus diferentes de similaridade.
A opção mais próxima da rede principal do Ethereum são as chamadas testnets.
As quatro testnets mais difundidas, por ordem cronológica de início, são as redes Ropsten, Kovan, Rinkeby, Sokol e Görli (também grafada como Goerli).
A rede Ropsten usa a mesma configuração e o algoritmo de consenso PoW da rede principal, produzindo a cópia mais fiel possível da dinâmica real da Blockchain, enquanto as outras utilizam configurações distintas e um tipo de algoritmo de consenso denominado como Prova de Autoridade \emph{(PoA)}.
Basicamente, a PoA restringe a tarefa do consenso sobre o estado da blockchain e inserção de novos blocos a um conjunto restrito de nós confiáveis chamados de autoridades, que realizam um processo de mineração\footnote{A fim de diferenciar algoritmos de consenso que não são baseados em hashing como o Proof-of-Work, alguns denominam sua atividade como cunhagem \emph{(minting)} ao invés de mineração \emph{(mining)}.} rotativa, distribuindo a responsabilidade da criação do bloco entre elas e estipulando regras de criação de blocos que evidenciam a tentativa de manipulação por nós maliciosos, permitindo a exclusão dessa entidade maliciosa, desde que a rede tenha uma composição majoritária de nós honestos \cite{DeAngelis2018}.

{\color{Magenta} 1 parágrafo para explicar que a rede Blockchain foi implantada em um computador usando o Ganache. Explicar o que é o ganache e o que entrega a implantação (X mineradores? X full nodes, etc).}

Enquanto as testnets oferecem uma forma de teste gratuita de uma rede com aspectos realísticos, o tempo para a confirmação das transações pode prolongar os testes e experimentação durante o desenvolvimento.
Ferramentas foram desenvolvidas para oferecer uma rede privada Ethereum em um ambiente controlado e determinístico, permitindo a escrita de testes, execução de comandos e facilitando a inspeção dos estados da EVM e das variáveis de Smart Contracts, destacando-se entre elas o Remix, um IDE online que executa uma EVM com um motor escrito em JavaScript diretamente no navegador Web e oferece ferramentas para implantação, interação e depuração de Smart Contracts e o Ganache, um programa que roda localmente, grava em disco o estado da simulação e expõe uma interface RPC para interação.
Este trabalho utilizou o Ganache para gerar uma rede determinística em ambiente controlado, a fim de estudar o comportamento das sucessivas versões dos contratos e as interações entre eles, e utilizou Remix para realizar a implantação dos contratos e para realizar transações manuais.

{\color{Magenta} 1 parágrafo para explicar que a Blockchain possui 5 contratos inteligentes mencionados na Seção anterior.}

Os Smart Contracts descritos na seção \ref{sec:sub:ImplementacaoSmartContracts} foram projetados inicialmente usando a EVM virtual do Remix, partindo para uma série de testes de integração com o código do Protótipo, com várias implantações em Blockchains virtuais usando o Ganache, e foram então publicadas na testnet Rinkeby.
Além dos contratos citados, foram criados dois contratos auxiliares: o \emph{SmartDCPABEUtility} que atua como uma biblioteca para os outros contratos, oferecendo funções de conversão de dados do tipo bytes em string e vice-versa, e o \emph{SmartDCPABERoot}, responsável por automatizar a gestão de dependências entre os contratos.

\begin{figure}[!h]
  \centering
  \includesvg{images/dependencias-SmartContracts.svg}
  \caption{Dependências entre os Smart Contracts}
  \label{fig:dependenciasSmartContracts}
\end{figure}

Quando um contrato é publicado na EVM do Ethereum, ele se torna um objeto imutável, sendo possível alterar somente os valores definidos como variáveis deste contrato.
Portanto, para alterar a lógica do contrato ou a estrutura de dados, é necessário publicar um novo contrato e também todos os outros contratos que fizessem uma referência estática ao endereço deste contrato.
O \emph{SmartDCPABERoot} auxilia o processo de injeção de novos valores de contrato e conta com uma trava de segurança em suas funções para somente aceitar como válidas as invocações feitas pelo dono do contrato, i.e., somente as transações cujo o endereço de carteira do autor coincidam com o usado na transação de criação do contrato.
A figura \ref{fig:dependenciasSmartContracts} mostra a dependência entre contratos gerenciados pelo contrato SmartDCPABERoot e que sem ele precisariam ser configurados manualmente a cada nova versão dos contratos durante o desenvolvimento.
O endereço da carteira usado para implantação dos contratos foi 0x584cf84bcc601da596b4f12a4c976577b40e9970, e os endereços dos contratos na Blockchain testnet Rinkeby estão na tabela \ref{tbl:enderecosSmartContracts}.
Os endereços são links clicáveis e direcionam para a página do respectivo contrato no site Etherscan, um serviço de exploração e pesquisa de transações, endereços e outros dados tanto na rede principal Ethereum quanto nas testnets.

\begin{table}[h]
  \begin{center}
    \begin{tabular}{ |c|c|c| }
      \hline
      Contrato & Endereço do contrato na rede Rinkeby \\
      \hline
      SmartDCPABERoot & \href{https://rinkeby.etherscan.io/address/0xad1c2b4d33bb1d373e5fbf0cc525390362433dd9#code}{0xAd1c2b4d33Bb1d373E5fBF0cC525390362433DD9} \\
      \hline
      SmartDCPABEAuthority & \href{https://rinkeby.etherscan.io/address/0x94f5cb858438cfc9841fb50f2d022d9a66168b67#code}{0x94f5Cb858438CFc9841FB50F2d022d9a66168b67 } \\
      \hline
      SmartDCPABEFiles & \href{https://rinkeby.etherscan.io/address/0xad1c2b4d33bb1d373e5fbf0cc525390362433dd9#code}{0xAd1c2b4d33Bb1d373E5fBF0cC525390362433DD9} \\
      \hline
      SmartDCPABEKeys & \href{https://rinkeby.etherscan.io/address/0x2b92348a73681debb4b2c111000f3cb1bfd143b5#code}{0x2B92348A73681dEbb4B2c111000f3CB1BfD143b5} \\
      \hline
      SmartDCPABERequests & \href{https://rinkeby.etherscan.io/address/0x76a5b0db83060951837363787bb0f711b1a2901d#code}{0x76A5b0dB83060951837363787Bb0f711b1A2901D} \\
      \hline
      SmartDCPABEUsers & \href{https://rinkeby.etherscan.io/address/0x9004de663614268a1663a9dcbe5a65e79542db0a#code}{0x9004de663614268a1663A9dCbe5A65E79542Db0A } \\
      \hline
      SmartDCPABEUtility & \href{https://rinkeby.etherscan.io/address/0xae0ac361c316a696cd4a89990036d95a45296841#code}{0xaE0aC361c316A696Cd4a89990036d95A45296841 } \\
      \hline
    \end{tabular}
  \caption{Endereços dos Smart Contracts na rede testnet Ethereum Rinkeby}
  \label{tbl:enderecosSmartContracts}
\end{center}
\end{table}

{\color{Magenta} 1 parágrafo para explicar que a implantação dos contratos inteligentes usou o Metamask. Explicar o que é o Metamask e o que especificamente você usou dele: ver identificadores das transações, conversão de .sol para .abi. Explicar o que é .abi.}

Como explicado anteriormente, a interação com a rede Ethereum é possível usando uma interface preparada para interação com um nó local da rede ou serviço remoto compatível com RPC Ethereum.
A biblioteca Web3, disponível para as linguagens de programação mais utilizadas, cumpre este propósito, porém sua implementação não conta com uma interface para interação com o usuário.
O Metamask surge como uma extensão compatível com os navegadores modernos, implementando uma interface de usuário a uma biblioteca Web3 que é disponibilizada ao ambiente JavaScript para utilização dos sites.
O Metamask introduz vantagens ao padronizar a forma com que usuários interagem e configuram a Web3 na internet e ao adotar o código aberto e a segurança proveniente deste método de desenvolvimento.
Sem o Metamask, seria necessário a um serviço Web importar o Web3 diretamente em seu projeto e implementar os controles necessários ao uso do serviço, introduzindo custos e riscos adicionais ao projeto. A IDE Remix é um exemplo de site que usa a Web3 diretamente, além de ser compatível com a injeção da Web3 configurada pelo Metamask.

\begin{figure}[!h]
  \centering
  \includesvg{images/infraestrutura-Blockchain.svg}
  \caption{Infraestrutura para integração de Smart Contracts do Ethereum a aplicações}
  \label{fig:infraestruturaBlockchain}
\end{figure}

A Figura \ref{fig:infraestruturaBlockchain} ilustra o esquema de infraestrutura utilizada para integrar a rede Ethereum ao ambiente de desenvolvimento da aplicação.
Em síntese, Smart Contracts na linguagem solidity são disponibilizados à IDE Web Remix, que se conecta à Blockchain por meio da biblioteca Web3 embutida na própria ferramenta ou injetada pelo Metamask, permitindo a implantação e execução de funções dos Smart Contracts.
A biblioteca Web3j cria classes Wrappers em Java dos contratos usando a especificação ABI e as instruções em bytecode gerados pela compilação dos arquivos escritos em Solidity no Remix.
As instâncias destas usam a Web3j como interface de conexão com a Blockchain.
A conexão com a Blockchain é feita por meio de um provedor de dados, que pode ser um nó local em execução, um gerador de Blockchain virtual para teste ou um serviço Web compatível com a RPC Ethereum.
A rede Ethereum (ou similar) processa as transações, acionando os Smart Contracts em execução na EVM e retornando dados de retorno das funções, juntamente com o novo estado da Blockchain.

{\color{RoyalBlue} Professor, a explicação do que é ABI está na seção \ref{sec:sub:contratos-ethereum}, porque lá já estou abordando o Solidity e o bytecode (EVM Code)}

% -------------------------------------------------------------------- %
\newpage
\section{Trabalhos Relacionados}

{\color{ForestGreen} Para cada trabalho, escrever um texto como o esqueleto mencionado abaixo (tentar manter esse esqueleto para todos os trabalhos relacionados):

Os autores  $\backslash$cite\{trabalhoX\} apresentam um sistema que [explicar "o que faz" o sistema em 2 linhas alto nível, não explicar o "como faz" nem os módulos]. Os principais módulos do sistema são: [listar os módulos, só o nome], os quais serão definidos a seguir.

O módulos X ... [1 parágrafo explicando o módulo].
O módulos Y ... [1  parágrafo explicando o módulo e tentar relacionar a interação com os outros módulos].

A principal diferença com o sistema proposto é [2 a 3 linhas].}

A ABE foi proposta inicialmente em 2005 \cite{Sahai2005}, em 2006 \cite{Goyal2006} é publicado o primeiro trabalho aplicando este novo esquema de criptografia a dados e a partir de 2010 \cite{Akinyele2010} a KP-ABE é aplicada com sucesso na área médica em um protótipo para gerenciar dados da Instituição Médica Johns Hopkins (Maryland, EUA).
A ideia da Blockchain surge juntamente e por meio do Bitcoin em 2008 \cite{nakamoto2008bitcoin} e as possibilidades de seu uso como um Livro-Razão Distribuído expandem-se intensamente com novas propostas de algoritmos e sistemas nas mais variadas áreas de aplicação.
Foi necessário a passagem do tempo para que se tornasse evidente a viabilidade da inovação trazida com o Bitcoin, atraindo a atenção do meio acadêmico que passou a estudar suas propriedades, alternativas e aplicações.
Em 2016 foram publicados os primeiros trabalhos na área médica com projetos usando Blockchain, focados em garantir a autenticidade de dados médicos com soluções baseadas em Blockchain \cite{Zhang2016,Azaria2016,Ekblaw2016}.
Adicionalmente o sistema MedRec também implementa um mecanismo para integração de dados de pacientes fragmentados entre bases de dados distintas.
O avanço das considerações da criptografia ABE e da Blockchain na área da saúde se encontraram em estudos recentes que serão analisados a seguir e comparados quando possível ao trabalho proposto aqui.

\subsection{Sistemas na área de saúde usando Blockchain e ABE}
\label{sec:sub:saude-blockchain-cba}

Em 2018 Sun et al. \cite{Sun2018} apresentam um sistema para assegurar a autenticidade de dados médico por meio de uma Blockchain privada e promover o anonimato dos usuários envolvidos no sistema ao substituir o mecanismo nativo de geração de chaves do Bitcoin por um esquema usando ABE.
Eles usam um cliente Bitcoin modificado para conter transações que representem registros de prontuários médicos (EHR) com substituição do mecanismos de geração de chaves e assinatura nativo do Bitcoin por outro baseado em um esquema ABE descentralizado que permite que múltiplas autoridades criem e concedam atributos a usuários.
A proposta foca na preservação do anonimato do usuário e propõe a ABE como forma de escapar às possibilidades de ataque de inferência para descobrir possíveis identidades de usuários usando o Bitcoin, entretanto não trabalha a questão quanto ao sigilo do conteúdo dos prontuários.
O trabalho proposto aqui difere do mencionado por dar enfoque ao sigilo da informação, não só propondo um esquema de criptografia como também elementos semânticos mínimos para que as múltiplas autoridades gerem atributos com hierarquia e escopos de atuação similares entre elas.

No mesmo ano Zhang e Lin \cite{Zhang2018} propõem o esquema BSPP \emph{(Blockchain-based secure and privacy-preserving)}, que protege tanto a identidade do paciente quanto o conteúdo dos prontuários ao mesmo tempo que concede acesso a terceiros previamente autorizados por meio do esquema de re-cifragem por \emph{proxy} com termos de pesquisa descrito em \cite{Wang2012}.
O paciente, no papel de usuário, consegue controlar o acesso aos seus dados de forma granular ao assumir a função de \emph{proxy}, gerando chaves de re-cifragem pelas quais é possível alterar uma cifra já realizada a um documento de forma a poder descriptografar e obter a mensagem original.
Esta chave é atrelada à chave pública de um terceiro de tal forma que somente o possuidor da chave privada correspondente poderá usá-la com sucesso.
Semelhante modo, a chave também é atrelada à chave pública de quem a cria e só é válida para cifras desta chave pública.
Adicionalmente a chave também é atrelada a um termo de pesquisa, restringindo sua atuação para funcionar somente nas cifras em que o termo escolhido constar entre o conjunto de termos definidos no momento da criptografia.
Embora não utilize explicitamente um esquema ABE, o resultado final é próximo a um sistema ABE se estabelecermos uma comparação onde termos de pesquisa sejam considerados chaves públicas de atributos.
Nesta ótica, os termos de pesquisa atrelados à cifra de um documento seriam equivalentes a uma política de acesso monótona utilizando somente operadores conjuntivos (OR); o papel de \emph{proxy} nas mãos do usuário seria comparável ao de uma autoridade certificadora; e para finalizar a analogia, a chave de re-cifragem concedida para algum usuário e referindo-se a algum termo de pesquisa específico seria similar à chave pessoal de um atributo com de mesmo nome, concedida a este mesmo usuário.

Visando a interoperabilidade entre instituições, Zhang e Lin sugerem o FHIR \emph{(Fast Healthcare Interoperability Resources)} \cite{HL72019} como um escopo comum de referência para a definição dos termos de pesquisa.
O trabalho proposto aqui busca este mesmo objetivo e produz taxonomias de permissões e papeis médicos em um contexto específico do Brasil (seção \ref{sec:sub:taxonomia-permissoes}), visando definir um escopo semântico comum e facilitar a interoperabilidade de todos integrantes do sistema de saúde em uma escala nacional.
Para assegurar a integridade e autenticidade dos dados médicos entre várias instituições os autores propõem o uso de dois tipos de blockchains.
As blockchains do primeiro tipo são privadas (particulares a cada instituição) e registram hashes dos dados de prontuários cifrados, enquanto uma outra blockchain única e de acesso compartilhado serve para indexar todos os dados e possibilitar a pesquisa por meio dos termos de pesquisa e identidades de usuário, obtendo-se os dados ao contatar as instituições donas das blockchains encontradas na pesquisa.
Em ambos os tipos de blockchains os autores adotam um mesmo mecanismo de consenso explícito e o denominam PoC \emph{(Proof of Conformity)}, aceitando a validade de novas transações e blocos somente quando estes forem declarados como válidos por no mínimo dois terços dos nós da rede, onde os nós utilizam trocas de mensagens via \emph{broadcast} para atingir este propósito.

\subsection{Sistemas na área de saúde com acesso online usando ABE}
\label{sec:sub:saude-nuvem-cba}

% -------------------------------------------------------------------- %
\newpage
\section{Resultados Experimentais}



% -------------------------------------------------------------------- %
\newpage
\section{Conclusões e Trabalhos futuros}

\begin{itemize}
  \item gasto financeiro
  \item problema energético
  \item sugestão: hyperledger Fabric / hyperledger Besu.
  \item implementar ZPK no servidor
\end{itemize}

\bibliography{doc}
\bibliographystyle{plainnat}

% -------------------------------------------------------------------- %
\newpage
\section{Anexo I}
\label{etc:anexoI}
PESSOAL DE SAÚDE - NÍVEL SUPERIOR
\begin{enumerate}
    \item ANESTESISTA
    \item ASSISTENTE SOCIAL
    \item BIOQUÍMICO/FARMACÊUTICO
    \item CIRURGIÃO GERAL
    \item CLÍNICO GERAL
    \item ENFERMEIRO
    \item FISIOTERAPEUTA
    \item FONOAUDIÓLOGO
    \item GINECO OBSTETRA
    \item MÉDICO DE FAMÍLIA
    \item NUTRICIONISTA
    \item ODONTÓLOGO
    \item PEDIATRA
    \item PSICÓLOGO
    \item PSIQUIATRA
    \item RADIOLOGISTA
    \item SANITARISTA
    \item OUTRAS ESPECIALIDADES MÉDICAS
    \item OUTRAS OCUPAÇÕES DE NÍVEL SUPERIOR RELACIONADOS À SAÚDE
\end{enumerate}
PESSOAL DE SAÚDE - NÍVEL TÉCNICO TÉCNICO/AUXILIAR
\begin{enumerate}
    \item AUXILIAR DE ENFERMAGEM
    \item FISCAL SANITÁRIO
    \item TÉCNICO DE ENFERMAGEM
    \item TÉCNICO E AUXILIAR DE FARMÁCIA
    \item TÉCNICO E AUXILIAR DE LABORATÓRIO
    \item TÉCNICO E AUXILIAR EM NUTRIÇÃO E DIETÉTICA
    \item TÉCNICO E AUXILIAR EM FISIOTERAPIA E REABILITAÇÃO
    \item TÉCNICO E AUXILIAR EM SAÚDE ORAL
    \item TÉCNICO E AUXILIAR EM VIG SANITÁRIA E AMBIENTAL
    \item TÉCNICO E AUXILIAR EM EQUIP MÉDICO-HOSPITALARES
    \item TÉCNICO E AUXILIAR EM RADIOLOGIA MÉDICA
    \item TÉCNICO E AUXILIAR EM HEMATOLOGIA/HEMOTERAPIA
    \item TÉCNICO E AUXILIAR EM HISTOLOGIA
    \item OUTRAS OCUPAÇÕES NÍVEL TÉCNICO E AUXILIAR EM SAÚDE
\end{enumerate}
PESSOAL DE SAÚDE - QUALIFICAÇÃO ELEMENTAR
\begin{enumerate}
    \item AGENTE COMUNITÁRIO DE SAÚDE
    \item AGENTE DE SAÚDE PÚBLICA
    \item ATENDENTE DE ENFERMAGEM/AUX OPER SERV DIV E ASSEM
    \item PARTEIRA
    \item OUTRAS OCUPAÇÕES NÍVEL ELEMENTAR EM SAÚDE
\end{enumerate}
PESSOAL ADMINISTRATIVO
\begin{enumerate}
    \item ADMINISTRAÇÃO
    \item SERVIÇO DE LIMPEZA/CONSERVAÇÃO
    \item SEGURANÇA
    \item OUTRAS OCUPAÇÕES ADMINISTRATIVAS
\end{enumerate}

\end{document}
