# Attribute-Based Encryption: Using Identity-Based Encryption for Access Control

Fichamento feito por Bruno Arruda, em 06/03/2019.

## AKINYELE, J. A. et al. Self-Protecting Electronic Medical Records Using Attribute-Based Encryption. ePrint IACR org, p. 1–20, 2010

## Resumo



## Citações

1. > "There are emerging XML-based standards for representing MRs, such as the Continuity of Care Record (CCR) and Continuity of Care Document (CCD). These standards call for protecting EMRs, but they do not provide enough guidance as to how such protection can be achieved" (p.1)
2. > "To validate our approach we implemented a system whereby users can access their EMRs offline, and can read and write their records to a Personal Health Record (PHR) system, such as Microsoft HealthVault, Georgia Tech’s MedVault [18] or Harvard’s Indivo [29]" (p.2)
3. > "To protect these exported records, our approach provides the following:"
   > 1. **End-to-end Encryption.** (...)
   > 2. **Role-based and Content-based Access Control.**
   >    - (...) In role-based access control [11, 14, 21, 35, 41], a record’s access control policy is based on roles associated with authorized accessors.
   >    - (...) In content-based access control, individuals are explicitly authorized to access collections of records matching certain criteria. We refer to these as collections as content slices.
   >    - (...) These slices are also defined via boolean formulae, though in this case the formulae are computed over the content tags our system associates with the record.
   > 3. **Automatic policy generation.** (...)".
4. > "Patients and providers can manually specify the policies appropriate to each data record; however, this imposes an impractical burden on providers [33]. Therefore a core component of our architecture is an automated policy engine that selects the encryption policy for each record based on a variety of factors." (p.5)
5. > "The design of the policy engine is implementation-specific. Our prototype implementation selects from a collection of pre-specified policies that are based on existing metadata tags applied by the hospital record coding system." (p.6)
6. > "If the record is marked for encryption, it can be encrypted using ciphertext-policy ABE or encrypted using a key-policy ABE scheme under a set of attributes identified by the policy engine (these may include record type, patient age, date, and other non-sensitive attributes related to the record)." (p.6-7)
7. > "**Granting Access**. Patients and authorized health care providers obtain one of two types of keys from the hospital’s ABE master controller. Ciphertext-policy or role keys embed fixed attributes related to the user (...). [temporary contractors and researchers] can be supported using the key-policy system: individual content keys will then specify a particular policy defining which records the key can access, e.g., “access to all cardiac-related labs for patients aged 42 and above.""
8. > "There are fields in a medical record that are considered by both individuals and legislation (such as HIPAA [10] and HITECH [20]) as highly sensitive and private and should not be made available to all that have access to an EMR, legitimate or otherwise." (p.7)
9. > "Our policy engine may be configured to automatically extract the patient’s parent’s name and birthday from the CCR, allowing the following string to be appended to any encryption strings generated by the policy engine:
    > <br> ∨ (Parent of Patient ∧ (Date < Patient's 12th Birthday)) <br>
    > This modification gives the patient’s parents the ability to decrypt the record provided that their ABE private key was issued before the patient’s 12th birthday. If the ABE private key was issued subsequently the patient’s 12th birthday, the Date attribute of their ABE private key would be greater than the year value of their 12th birthday, resulting in the policy evaluating to “false”, and the parents would be unable to decrypt his records." (p.8)
10. > "If the patient’s parent wishes to decrypt the patient’s records, the parent can authenticate to the hospital ABE controller to obtain the private key corresponding to the “Parent of [patient name]” attribute. This private key allows the parent to decrypt any record that was encrypted with appended string:
    > ∨ Parent of Patient." (p.8)
11. > "By classifying ADs into these two categories, we can separate the long-term care ADs from those ADs needed during emergencies. Our system allows us to protect the long-term care AD without interfering with normal hospital procedures. Whereas the emergency-care AD remains unencrypted in the hospital, the long-term care AD can be protected with a form of ABE nested encryption. After the patient has finalized her long-term care AD, she can query the hospital’s ABE controller to encrypt the document with the policy of her choice. For example, this string might be the following:
    > <br> Sister of Patient ∨ Daughter of Patient <br>
    > Consequently, either the patient’s sister or the patient’s daughter must be present to decrypt the AD. This is the inner encryption of the nested encryption scheme for long-term ADs. Its purpose is to restrict read access to the long-term AD to only those named in the ABE policy."
12. > "Accordingly, our policy engine is responsible for ensuring that the AD is protected before being transmitted to the outside world. If an AdvanceDirective node is encountered during the traversal of the CCR, the policy engine automatically encrypts the entire node with the hospital’s ABE attribute. This is the outer encryption of the nested encryption scheme for long-term ADs, although emergency-care ADs are also encrypted with the hospital’s ABE attribute before being transmitted so they are not sent in the clear. For long-term ADs, the inner encryption restricts read access to only those specified in the ABE policy; the outer encryption restricts read access to the ABE policy itself to only the hospital before the encrypted AD is sent externally." (p.9)
13. > "we implemented a Python-based policy engine that evaluates EMRs based on CCR-compliant metadata, and determines the appropriate policy from a set of policies provided by the provider". (p.9)
14. > "we have integrated the GraphViz [5] and yapgvb [9] Python packages into our policy engine." (p.20)
15. > "To support nested encryption of a record, our policy engine uses a post-order traversal on the CCR. We choose post-order traversal to enable nested encryption at the most granular level–by visiting the XML leaves first before visiting their parent nodes, we retain the option to encrypt the children (inner encryption) first and then their parent nodes (outer encryption) afterward. This choice provides maximum flexibility and security when encrypting an EMR." (p.10)
16. > "Our policy engine reports that this node should be left in the clear. The next node considered is Medication B, but our engine reports that this node should be encrypted. When configuring their access control rules and policies, the EMR administrator can specify whether just the body of the node should be encrypted, or whether the tag name itself should be encrypted as well." (p.10)
17. > "We authenticate the patient via a username and password to the web service and retrieve the patient’s ABE-encrypted CCR. Once the encrypted record is downloaded to the phone, the application uses ABE private-keys stored in the iPhone keychain to decrypt the records." (p.11)
18. > "Our application performs “lazy” decryption–only decrypting records on an as-needed basis. As a result, we use less memory and less processing power, con- serving battery life". (p.12)
19. > "An advantage of the tmp directory is that the system will delete all data stored in the directory when the user exits the application. However, the ABE-encrypted CCR can be written in the application’s local filesystem and remain self-protected". (p.13)
20. > "**Encoding of Encrypted CCRs.** Our scheme is straightforward and takes advantage of the flexibility provided by the CCR specification. We base-64 encode the EncryptedData XML nodes and the ciphertext and move them to another location in the CCR’s Body, such that the EncryptedData XML appears as regular text. As part of the encoding, we add a special identifier so that we can put the CCR back together when we download the record. Because we move the EncryptedData XML, the CCR is malformed from Google’s perspective and would not be accepted. To remedy this, we add artificial CCR XML nodes in place of the EncryptedData XML, complying with Google Health’s format requirements." (p.12)
21. > "Because the key server (or PKG) has the ability to generate arbitrary private keys, it is important that the server be kept offline and keys be transferred manually to patient’s mobile devices (e.g. via a USB connection)". (p.12)
22. > "Upon authenticating the patient, the hospital PKG generates the patient’s ABE private keys, a public-key certificate, and a RSA public and private key-pair. The certificate authenticates the attributes or policy placed on the patient’s ABE keys and includes an expiration date for the keys." (p.13)
23. > "The certificate is digitally signed by a trusted certificate authority such as an RHIO and is used to retrieve future key updates". (p.13)
24. > "Once the ABE keys have been secured on the patient’s iPhone, physical presence at the hospital is no longer required for the patient to receive updates to their ABE private keys. The RSA public key-pair established at the initial provisioning allows the patient to securely receive key updates remotely." (p.13)
25. > "To validate the practicality of applying ABE techniques to medical records, we (...) first measured the time required for encryption and decryption processing (...). To show that our techniques induce an acceptable cost in terms of records storage, we also measured the ciphertext size overhead incurred by our encryption solution." (p.14)
26. > "encryption and decryption times in our ABE library are a direct function of the number of attributes in the access policy". (p.15)
27. > "A major exception to this rule involves policies with comparison operators (e.g. <, >, ≤, ≥), since as per Bethencourt et al. [16] these operators are transformed by a pre-processor into boolean formulae. This pre-processing induces a policy blowup that is dependent on the size of the literals being compared." (p.15)
28. > "**Methodology.** To calculate our CP-ABE micro benchmarks we employed the following strategy. For values of N ranging from 1 to 100 we encrypted a message under a policy consisting of a single AND gate with N distinct attribute leaves. We then generated a key containing all N attributes. We instrumented both the encryption and decryption process in order to determine the time required for each operation. For KP-ABE we employed a similar methodology, though the access policy was placed within the generated key." (p.15)
29. > "To support the latter application we strongly recommend the use of the “lite” scheme even though it necessitates a larger private key size. In practice, for policy sizes under 30 leaves (the vast majority of cases we have investigated), we believe that all of the schemes have acceptable performance." (p.15)
30. > "To determine the storage overhead incurred by our ABE implementation, we conduct experiments on a small set of medical records obtained from the Vanderbilt University Medical Center (VUMC) which are in the Vanderbilt StarChart Data (VSD) format. (...)  For our basic test, we selected the largest record in our set that contains 3056 XML nodes. Each node varies in size and the total size of the VSD is 8.3MB". (p.16)
31. > "**Methodology.** To measure the storage overhead, we encrypted the records under CP-ABE using three separate policy profiles: Profile 1 encrypts 10% or 306 nodes chosen at random, Profile 2 encrypts 25% or 764 nodes chosen at random, and Profile 3 encrypts all nodes in the medical record. We performed each trial with two different ABE encryption policies in order to evaluate the growth in medical record sizes as policy complexity increases. The first policy is based on our advance directive use case discussed in Section 4.3 and represents a simple ABE policy:" (P.16)
32. > "Our “Minor” example represents perhaps the worst case and increases from 8.3MB to 46MB when all of the nodes are encrypted. This is due to the < and > operators that add, in this case, 32 additional attributes to the policy tree. Due to the metadata required by the CP-ABE scheme, each encryption of a node adds 68 bytes of overhead per encryption and approximately 250 bytes per policy attribute. This overhead is in addition to the size of the policy description, which is represented as a null- terminated ASCII string. In total, an ABE encryption using our “Minor” policy requires 9,183 bytes of overhead per encryption (not including the encrypted plaintext)." (P.16-17)
33. > "Several EMR and PCHR systems have been proposed or implemented to enable access control on electronic medical records [31]. The most notable solution is the Indivo X platform [29]" (p.17)